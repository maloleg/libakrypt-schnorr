/* --------------------------------------------------------------------------------- */
/* Пример example-g03n02.c                                                           */
/* --------------------------------------------------------------------------------- */
 #include <stdio.h>
 #include <libakrypt.h>

 int main( void )
{
  int i = 0;

 /* контекст секретного ключа */
  struct bckey ctx;
 /* значение синхропосылки */
  ak_uint8 iv[8] = { 0x03, 0x07, 0xae, 0xf1 };
 /* массив данных для защифрования длины 313 байт (19*16 + 9 = 6*48 + 25) */
  ak_uint8 data[313], out[313], out2[313];

 /* инициализируем криптобиблиотеку
    и явно указываем функцию вывода сообщений аудита */
  if( ak_libakrypt_create( NULL ) != ak_true ) {
    ak_libakrypt_destroy();
    return EXIT_FAILURE;
  }

 /* формируем исходные данные */
  for( i = 0; i < 313; i++ ) data[i] = (ak_uint8)i;

 /* создаем ключ и присваиваем ему значение, выработанное из пароля пользователя */
  ak_bckey_create_oid( &ctx, ak_oid_find_by_name( "kuznechik"));
  ak_bckey_set_key_from_password( &ctx, "password", 8, "rand", 4 );

 /* зашифровываем данные блоками, длина которых кратна длине блока
    используемого блочного шифра.
    в первом случае, явно указывается значение имитовставки */
  ak_bckey_ctr( &ctx, data, out, 48, iv, 8 );
 /*  в остальных случаях - оно заменяется на null-указатель */
  for( i = 1; i < 6; i++ )
     ak_bckey_ctr( &ctx, data +i*48, out +i*48, 48, NULL, 0 );
 /* последний фрагмент, длина которого не кратна длине блока (16) */
  ak_bckey_ctr( &ctx, data +288, out +288, 25, NULL, 0 );

 /* зашифровываем данные единым фрагментом и проверяем,
    что оба подхода к реализации дают один и тот результат */
  ak_bckey_ctr( &ctx, data, out2, 313, iv, 8 );
  if( ak_ptr_is_equal_with_log( out, out2, 313 ) == ak_true ) printf("Ok\n");

 /* освобождаем контекст секретного ключа */
  ak_bckey_destroy( &ctx );
  ak_libakrypt_destroy();

 return EXIT_SUCCESS;
}
