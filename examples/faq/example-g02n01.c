/* --------------------------------------------------------------------------------- */
/* Пример example-g02n01.c                                                           */
/* --------------------------------------------------------------------------------- */
 #include <stdio.h>
 #include <libakrypt.h>

 int main( void )
{
    int i = 0;
    char *str = NULL;
    ak_uint32 temp[4];
    const ak_uint32 buf[4] = { 2781913, 19724441, 16537891, 911018831 };

  /* вывод преобразованной строки данных
     первый аргумент:
       - область память, которая преобразуется в строку шестнадцатеричных символов
     второй аргумент:
       - размер преобразуемой память (в байтах)
     третий аргумент:
       - флаг записи преобразованных данных в обратном порядке
        ( значение ak_false означает, что данные выводятся без "разворота" ) */
    printf("1: %s\n", ak_ptr_to_hexstr( buf, sizeof( buf ), ak_false ));

   /* те же данные, но в обратной последовательности */
    printf("2: %s\n", ak_ptr_to_hexstr( buf, sizeof( buf ), ak_true ));

   /* еще одно преобразование того же массива данных,
      но с выделением оперативной памяти */
    printf("3: %s\n", str = ak_ptr_to_hexstr_alloc( buf, sizeof( buf ), ak_false ));
    free( str );

   /* обратное преобразование строки символов в двоичные данные
      и проверка того, что после преобразования данные совпали  */
    ak_hexstr_to_ptr( "d9722a0099f82c012359fc004f0b4d36", temp, 16, ak_false );
    for( i = 0; i < 4; i++ ) if( temp[i] != buf[i] ) return EXIT_FAILURE;

   /* легко проверить, что преобразование не зависит от регистра
                             в котором записаны символы в строке */
    ak_hexstr_to_ptr( "D9722A0099F82C012359FC004F0B4D36", temp, 16, ak_false );
    for( i = 0; i < 4; i++ ) if( temp[i] != buf[i] ) return EXIT_FAILURE;
    printf("Ok\n");

 return EXIT_SUCCESS;
}
