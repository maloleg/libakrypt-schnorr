Техническое описание
====================

В этом разделе содержится информация о том, как библиотека `libakrypt` реализована и устроена изнутри, 
какие принципы и какие идеи в нее заложены;
приводятся пояснения о ньюансах реализации криптографических преобразований.

Данная информация может оказаться полезной тем, кто захочет модифицировать исходный текст библиотеки или расширить ее
функциональные возможности.
Те же, кто хочет сразу начать работу с фукциями библиотеки,
могут переходить в раздел `FAQ по встраиванию <faq.html>`__.

Текущее описание не является завершенным и будет дополняться с течением времени.


Идентификаторы объектов (OID)
-----------------------------

Идентификато объекта (`Object IDentifier`, `oid`) это уникальная последовательность чисел, разделенных точками.
Уникальный идентификатор может быть присвоен любому криптографическому механизму (алгоритму, схеме или протоколу),
а также произвольным параметрам этих механизмов. Использование `oid`-ов позволяет однозначно определять тип криптографического
механизма или значения его параметров на этапе выполнения программы, а также однозначно связывать данные
с алгоритмами, в которых эти данные используются.

Все идентификаторы образуют одно большое дерево,
поддерживаемое уполномоченными на то организациями в соответствии с международным
стандартом `ГОСТ Р ИСО/МЭК 9834-1-2009 <https://files.stroyinf.ru/Data2/1/4293825/4293825307.pdf>`__.

Корень российского дерева идентификаторов образует идентификатор `1.2.643`.
Далее дерево выглядит следующим образом

    - `1.2.643.1`  Операторы связи (communication organization)
    - `1.2.643.2`  `Производители программного обеспечения <https://oid.iitrust.ru/oid_search/11/>`__ (program organization)
    - `1.2.643.3`  Удостоверяющие центры (certificate authority)
    - `1.2.643.4`  Банки (banks)
    - `1.2.643.5`  Органы власти и государственные организации (government organization)
    - `1.2.643.6`  Прочие организации (another organization)
    - `1.2.643.7`  Организации по стандартизации (organization of standardization); сюда, в частности, входит Технический комитет по стандартизации ТК26 "Криптографическая защита информации"
    - `1.2.643.8`  Образовательные организации (organization of education)
    - `1.2.643.9`  Муниципальные образования (municipalities)
    - `1.2.643.10` Индивидуальные предприниматели (individual businessman)


Библиотека `libakrypt` поддерживает свое собственное дерево идентификаторов, корнем которого
служит последовательность `1.2.643.2.52.1`.
В данном случае, значение ``52`` закреплено за
Московским институтом электроники и математики им. А.Н.Тихонова (`МИЭМ <https://miem.hse.ru>`__).

Дерево библиотеки используется в случае, когда идентификаторы алгоритмов не определены ни рекомендациями ТК 26,
ни существующими реализациями других производителей
программного обеспечения.

Поддеревья алгоритмов и их параметров определяются следующим образом.

  - `1.2.643.2.52.1.1` - генераторы псевдо-случайных чисел,
  - `1.2.643.2.52.1.2` - алгоритмы поточного шифрования,
  - `1.2.643.2.52.1.3` - режимы работы поточных шифров,
  - `1.2.643.2.52.1.4` - алгоритмы блочного шифрования,
  - `1.2.643.2.52.1.5` - базовые режимы работы блочных шифров,
  - `1.2.643.2.52.1.6` - расширенные режимы работы блочных шифров,
  - `1.2.643.2.52.1.7` - алгоритмы выработки имитовставки,

  - `1.2.643.2.52.1.10` - алгоритмы выработки электронной подписи,
  - `1.2.643.2.52.1.11` - алгоритмы проверки электронной подписи,
  - `1.2.643.2.52.1.12` - параметры эллиптических кривых

  - `1.2.643.2.52.1.181` - алгоритмы генерации ключевой информации для схемы Блома
  - `1.2.643.2.52.1.127` - контейнеры библиотеки
  - `1.2.643.2.52.1.98`  - расширения инфраструктуры открытых ключей (PKIX)

 .. note:: Вывести в консоль реализованные в библиотеке идентификаторы можно с помощью вызова `aktool s --oids`. Детальное описание использованной утилиты `aktool` содержится в соотвествующем `разделе <aktool.html>`__ документации.

Технически, идентификатор объекта реализован как структура,
позволяющая связать воедино:

  * списки имен (каждый `oid` может иметь несколько имен),
  * списки идентификаторов (каждый `oid` может иметь несколько идентификаторов, присвоенных различными организациями),
  * указатель на двоичные данные (это, как правило, явно заданные параметры криптографических алгоритмов),
  * а также набор функций, позволяющих создавать, удалять и управлять объектами (секретными ключами) криптографических преобразований.

.. code-block:: c

  typedef struct oid {
   /*! \brief Тип криптографического механизма. */
    oid_engines_t engine;
   /*! \brief Режим применения криптографического механизма. */
    oid_modes_t mode;
   /*! \brief Перечень идентификаторов криптографического механизма. */
    const char **id;
   /*! \brief Перечень доступных имен криптографического механизма. */
    const char **name;
   /*! \brief Указатель на данные. */
    ak_pointer data;
   /*! \brief Структура, контролирующая поведение объектов криптографического механизма. */
    struct functional_objects func;
  } *ak_oid;

При этом структура `functional_objects` определяется следующим образом.

.. code-block:: c

  typedef struct object {
  /*! \brief Размер области памяти для первого объекта. */
   size_t size;
  /*! \brief Конструктор первого объекта. */
   ak_function_create_object *create;
  /*! \brief Деструктор первого объекта. */
   ak_function_destroy_object *destroy;
  /*! \brief Функция, выполняющая присвоение фиксированного ключа. */
   ak_function_set_key_object *set_key;
  /*! \brief Функция, выполняющая выработку нового случайного ключа. */
   ak_function_set_key_random_object *set_key_random;
  /*! \brief Функция, выполняющая выработку ключа из пароля. */
   ak_function_set_key_from_password_object *set_key_from_password;
  } *ak_object;


.. code-block:: c

  typedef struct functional_objects {
   /*! \brief Управляющий объект криптографического алгоритма */
    struct object first;
   /*! \brief Второй объект, в ряде алгоритмов - второй ключ криптографического алгоритма */
    struct object second;
   /*! \brief Функция выполняющая прямое преобразование.
     В качестве такого преобразования может выступать, например, режим зашифрования
     для блочного шифра или алгоритм выработки имитовставки. */
    ak_function_run_object *direct;
   /*! \brief Функция выполняющая обратное преобразование.
     В качестве такого преобразования может выступать, например, режим расшифрования
     для блочного шифра. */
    ak_function_run_object *invert;
  } *ak_functional_objects;

Столь сложный способ определения идентификатора объекта позволяет
по известному идентификатору криптографического алгоритма
иметь возможность не только создавать, но и присваивать значения ключам криптографических алгоритмов,
а также выполнять сами криптографические преобразования.

Для доступа к идентификаторам реализованы функции поиска идентификаторов по заданным именам, последовательностям чисел, разделенных точками,
а также типам (`oid_engines_t`) и режимам (`oid_modes_t`) криптографических преобразований.


Соглашение о наименовании функций
---------------------------------


.. code-block:: c

  int main( void )
 {
   return EXIT_SUCCESS;
 }


.. c:function:: int ak_aead_create_xtsmac_kuznechik( ak_aead ctx, bool_t crf )

   Return a list of random ingredients as strings.

   :param ctx: Optional "kind" of ingredients.
   :type kind: ak_aead
   :param crf: Optional "kind" of ingredients.
   :type bool_t: ak_aead

   :return: The ingredients list.
   :rtype: int
