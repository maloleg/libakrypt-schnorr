Простейшие криптографические преобразования
===========================================

Шифрование данных
-----------------

Шифрование данных представляет собой процедуру преобразования
исходных данных с помощью секретного ключа.
В библиотеке ``libakrypt`` принято соглашение, по которому,
каждый ключ предназначается для одного или небольшого класса однотипных
криптографических преобразований, т.е. ключ шифрования данных нельзя использовать
для их имитозащиты или выработки электронной подписи.

Реализация подобного соглашения подразумевает,
что каждому ключу соответствует контекст, содержащий как сам ключ,
так и указатели на методы, предназначенные для его обработки.

Обычная последовательность использования ключа состоит из нескольких простых шагов:

  1. создание контекста ключа
  2. присвоение ключу секретного значения
  3. обработка данных (зашифрование, расшифрование, выработка имитовставки и т.п.)
  4. освобождение контекста ключа.

Рассмотрим перечисленные шаги более подробно на примере
алгоритмов блочного шифрования.

Для создания ключа могут быть использованы следующие функции:

 - :func:`int ak_bckey_create_magma`;
 - :func:`int ak_bckey_create_kuznechik`;
 - :func:`int ak_bckey_create_oid`.

Первым аргументом указанных функций
служит указатель контекст создаваемого секретного ключа - структуру ``struct bckey``.
Вызов функции в явном виде указывает для какого алгоритма блочного шифрования предназначается
контекст секретного ключа. В настоящее время в библиотеке реализованы
два отечественных алгоритма блочного шифрования - Магма и Кузнечик,
регламентируемые стандартом ГОСТ Р 34.12-2015.

Функция :func:`int ak_bckey_create_oid` обладает двумя арументами и
позволяет создать контекст секретного ключа с использованием идентификатора объекта (``struct oid``).

После создания ключа ему должно быть присвоено некоторое значение.
Это можно сделать с помощью следующих функций.

 - :func:`int ak_bckey_set_key`;
 - :func:`int ak_bckey_set_key_random`;
 - :func:`int ak_bckey_set_key_from_password`.

Первая функция выполняет присвоение ключу константного значения.
Вторая функция вырабатывает случайное значение ключа с использованием заданного генератора случайных чисел.
Последняя функция вырабатывает значение ключа из строки символов, являющейся,
как правило, паролем пользователя.

Для шифрования данных предназначено несколько функций,
реализующих различные режимы шифрования:

 - :func:`int ak_bckey_encrypt_cbc` - зашифрование в режиме простой замены с зацеплением;
 - :func:`int ak_bckey_decrypt_cbc` - расшифрование в режиме простой замены с зацеплением;
 - :func:`int ak_bckey_ctr` - шифрование в режиме гаммирования;
 - :func:`int ak_bckey_ofb` - шифрование в режиме гаммирования с обратной связью по выходу;
 - :func:`int ak_bckey_encrypt_cfb` - зашифрование данных в режиме гаммирования с обратной связью по шифртексту;
 - :func:`int ak_bckey_decrypt_cfb` - расшифрование данных в режиме гаммирования с обратной связью по шифртексту;
 - :func:`int ak_bckey_ctr_acpkm` - шифрование данных в режиме `CTR-ACPKM`;
 - :func:`int ak_bckey_encrypt_xts` - зашифрование данных в режиме `XTS`;
 - :func:`int ak_bckey_decrypt_xts` - расшифрование данных в режиме `XTS`.

Простейший пример, иллюстрирующий процесс шифрования данных,
содержащихся в оперативной памяти, приводится ниже (файл ``example-g03n01.c``).

.. literalinclude:: ../examples/faq/example-g03n01.c
 :language: c
 :linenos:

Контекст секретного ключа
сохраняет состояние пременных, используемых для реализаии режима гаммирования.
Это позволяет зашифровывать информацию не за один вызов функции,
а несколькими фрагментами, длина которых кратна длине блока алгоритма шифрования.
Такая особенность может быть востребована при обработке потоковых данных,
без необходимости их буфферезированного хранения в памяти вычислительного средства.
Пример такой обработки данных приводится в следующем примере (файл ``example-g03n02.c``).

.. literalinclude:: ../examples/faq/example-g03n02.c
 :language: c
 :linenos:



..
   Хеширование и вычисление имитовставок
   =====================================

   Аутентифицированное шифрование (AEAD)
   =====================================

Генерация псевдослучайных последовательностей
=============================================
