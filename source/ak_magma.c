/* ----------------------------------------------------------------------------------------------- */
/*  Copyright (c) 2014 - 2021 by Axel Kenzo, axelkenzo@mail.ru                                     */
/*                            by Mikhail Lavrinovich, mikhail.lavrinovich@netcracker.com           */
/*                                                                                                 */
/*  Файл ak_magma.h                                                                                */
/*  - содержит реализацию алгоритма блочного шифрования Магма,                                     */
/*    регламентированного ГОСТ Р 34.12-2015                                                        */
/* ----------------------------------------------------------------------------------------------- */
 #include <libakrypt-internal.h>

/* о маскированной реализации Магмы смотри
   S. V. Matveev, “GOST 28147-89 masking against side channel attacks”,
   Матем. вопр. криптогр., 6:2 (2015).                                   */

/* ----------------------------------------------------------------------------------------------- */
 static const magma magma_boxes[2][2] = {
  {
   {
    {
     0x6C, 0x64, 0x66, 0x62, 0x6A, 0x65, 0x6B, 0x69, 0x6E, 0x68, 0x6D, 0x67, 0x60, 0x63, 0x6F, 0x61,
     0x8C, 0x84, 0x86, 0x82, 0x8A, 0x85, 0x8B, 0x89, 0x8E, 0x88, 0x8D, 0x87, 0x80, 0x83, 0x8F, 0x81,
     0x2C, 0x24, 0x26, 0x22, 0x2A, 0x25, 0x2B, 0x29, 0x2E, 0x28, 0x2D, 0x27, 0x20, 0x23, 0x2F, 0x21,
     0x3C, 0x34, 0x36, 0x32, 0x3A, 0x35, 0x3B, 0x39, 0x3E, 0x38, 0x3D, 0x37, 0x30, 0x33, 0x3F, 0x31,
     0x9C, 0x94, 0x96, 0x92, 0x9A, 0x95, 0x9B, 0x99, 0x9E, 0x98, 0x9D, 0x97, 0x90, 0x93, 0x9F, 0x91,
     0xAC, 0xA4, 0xA6, 0xA2, 0xAA, 0xA5, 0xAB, 0xA9, 0xAE, 0xA8, 0xAD, 0xA7, 0xA0, 0xA3, 0xAF, 0xA1,
     0x5C, 0x54, 0x56, 0x52, 0x5A, 0x55, 0x5B, 0x59, 0x5E, 0x58, 0x5D, 0x57, 0x50, 0x53, 0x5F, 0x51,
     0xCC, 0xC4, 0xC6, 0xC2, 0xCA, 0xC5, 0xCB, 0xC9, 0xCE, 0xC8, 0xCD, 0xC7, 0xC0, 0xC3, 0xCF, 0xC1,
     0x1C, 0x14, 0x16, 0x12, 0x1A, 0x15, 0x1B, 0x19, 0x1E, 0x18, 0x1D, 0x17, 0x10, 0x13, 0x1F, 0x11,
     0xEC, 0xE4, 0xE6, 0xE2, 0xEA, 0xE5, 0xEB, 0xE9, 0xEE, 0xE8, 0xED, 0xE7, 0xE0, 0xE3, 0xEF, 0xE1,
     0x4C, 0x44, 0x46, 0x42, 0x4A, 0x45, 0x4B, 0x49, 0x4E, 0x48, 0x4D, 0x47, 0x40, 0x43, 0x4F, 0x41,
     0x7C, 0x74, 0x76, 0x72, 0x7A, 0x75, 0x7B, 0x79, 0x7E, 0x78, 0x7D, 0x77, 0x70, 0x73, 0x7F, 0x71,
     0xBC, 0xB4, 0xB6, 0xB2, 0xBA, 0xB5, 0xBB, 0xB9, 0xBE, 0xB8, 0xBD, 0xB7, 0xB0, 0xB3, 0xBF, 0xB1,
     0xDC, 0xD4, 0xD6, 0xD2, 0xDA, 0xD5, 0xDB, 0xD9, 0xDE, 0xD8, 0xDD, 0xD7, 0xD0, 0xD3, 0xDF, 0xD1,
     0x0C, 0x04, 0x06, 0x02, 0x0A, 0x05, 0x0B, 0x09, 0x0E, 0x08, 0x0D, 0x07, 0x00, 0x03, 0x0F, 0x01,
     0xFC, 0xF4, 0xF6, 0xF2, 0xFA, 0xF5, 0xFB, 0xF9, 0xFE, 0xF8, 0xFD, 0xF7, 0xF0, 0xF3, 0xFF, 0xF1,
    },
    {
     0xCB, 0xC3, 0xC5, 0xC8, 0xC2, 0xCF, 0xCA, 0xCD, 0xCE, 0xC1, 0xC7, 0xC4, 0xCC, 0xC9, 0xC6, 0xC0,
     0x8B, 0x83, 0x85, 0x88, 0x82, 0x8F, 0x8A, 0x8D, 0x8E, 0x81, 0x87, 0x84, 0x8C, 0x89, 0x86, 0x80,
     0x2B, 0x23, 0x25, 0x28, 0x22, 0x2F, 0x2A, 0x2D, 0x2E, 0x21, 0x27, 0x24, 0x2C, 0x29, 0x26, 0x20,
     0x1B, 0x13, 0x15, 0x18, 0x12, 0x1F, 0x1A, 0x1D, 0x1E, 0x11, 0x17, 0x14, 0x1C, 0x19, 0x16, 0x10,
     0xDB, 0xD3, 0xD5, 0xD8, 0xD2, 0xDF, 0xDA, 0xDD, 0xDE, 0xD1, 0xD7, 0xD4, 0xDC, 0xD9, 0xD6, 0xD0,
     0x4B, 0x43, 0x45, 0x48, 0x42, 0x4F, 0x4A, 0x4D, 0x4E, 0x41, 0x47, 0x44, 0x4C, 0x49, 0x46, 0x40,
     0xFB, 0xF3, 0xF5, 0xF8, 0xF2, 0xFF, 0xFA, 0xFD, 0xFE, 0xF1, 0xF7, 0xF4, 0xFC, 0xF9, 0xF6, 0xF0,
     0x6B, 0x63, 0x65, 0x68, 0x62, 0x6F, 0x6A, 0x6D, 0x6E, 0x61, 0x67, 0x64, 0x6C, 0x69, 0x66, 0x60,
     0x7B, 0x73, 0x75, 0x78, 0x72, 0x7F, 0x7A, 0x7D, 0x7E, 0x71, 0x77, 0x74, 0x7C, 0x79, 0x76, 0x70,
     0x0B, 0x03, 0x05, 0x08, 0x02, 0x0F, 0x0A, 0x0D, 0x0E, 0x01, 0x07, 0x04, 0x0C, 0x09, 0x06, 0x00,
     0xAB, 0xA3, 0xA5, 0xA8, 0xA2, 0xAF, 0xAA, 0xAD, 0xAE, 0xA1, 0xA7, 0xA4, 0xAC, 0xA9, 0xA6, 0xA0,
     0x5B, 0x53, 0x55, 0x58, 0x52, 0x5F, 0x5A, 0x5D, 0x5E, 0x51, 0x57, 0x54, 0x5C, 0x59, 0x56, 0x50,
     0x3B, 0x33, 0x35, 0x38, 0x32, 0x3F, 0x3A, 0x3D, 0x3E, 0x31, 0x37, 0x34, 0x3C, 0x39, 0x36, 0x30,
     0xEB, 0xE3, 0xE5, 0xE8, 0xE2, 0xEF, 0xEA, 0xED, 0xEE, 0xE1, 0xE7, 0xE4, 0xEC, 0xE9, 0xE6, 0xE0,
     0x9B, 0x93, 0x95, 0x98, 0x92, 0x9F, 0x9A, 0x9D, 0x9E, 0x91, 0x97, 0x94, 0x9C, 0x99, 0x96, 0x90,
     0xBB, 0xB3, 0xB5, 0xB8, 0xB2, 0xBF, 0xBA, 0xBD, 0xBE, 0xB1, 0xB7, 0xB4, 0xBC, 0xB9, 0xB6, 0xB0,
    },
    {
     0x57, 0x5F, 0x55, 0x5A, 0x58, 0x51, 0x56, 0x5D, 0x50, 0x59, 0x53, 0x5E, 0x5B, 0x54, 0x52, 0x5C,
     0xD7, 0xDF, 0xD5, 0xDA, 0xD8, 0xD1, 0xD6, 0xDD, 0xD0, 0xD9, 0xD3, 0xDE, 0xDB, 0xD4, 0xD2, 0xDC,
     0xF7, 0xFF, 0xF5, 0xFA, 0xF8, 0xF1, 0xF6, 0xFD, 0xF0, 0xF9, 0xF3, 0xFE, 0xFB, 0xF4, 0xF2, 0xFC,
     0x67, 0x6F, 0x65, 0x6A, 0x68, 0x61, 0x66, 0x6D, 0x60, 0x69, 0x63, 0x6E, 0x6B, 0x64, 0x62, 0x6C,
     0x97, 0x9F, 0x95, 0x9A, 0x98, 0x91, 0x96, 0x9D, 0x90, 0x99, 0x93, 0x9E, 0x9B, 0x94, 0x92, 0x9C,
     0x27, 0x2F, 0x25, 0x2A, 0x28, 0x21, 0x26, 0x2D, 0x20, 0x29, 0x23, 0x2E, 0x2B, 0x24, 0x22, 0x2C,
     0xC7, 0xCF, 0xC5, 0xCA, 0xC8, 0xC1, 0xC6, 0xCD, 0xC0, 0xC9, 0xC3, 0xCE, 0xCB, 0xC4, 0xC2, 0xCC,
     0xA7, 0xAF, 0xA5, 0xAA, 0xA8, 0xA1, 0xA6, 0xAD, 0xA0, 0xA9, 0xA3, 0xAE, 0xAB, 0xA4, 0xA2, 0xAC,
     0xB7, 0xBF, 0xB5, 0xBA, 0xB8, 0xB1, 0xB6, 0xBD, 0xB0, 0xB9, 0xB3, 0xBE, 0xBB, 0xB4, 0xB2, 0xBC,
     0x77, 0x7F, 0x75, 0x7A, 0x78, 0x71, 0x76, 0x7D, 0x70, 0x79, 0x73, 0x7E, 0x7B, 0x74, 0x72, 0x7C,
     0x87, 0x8F, 0x85, 0x8A, 0x88, 0x81, 0x86, 0x8D, 0x80, 0x89, 0x83, 0x8E, 0x8B, 0x84, 0x82, 0x8C,
     0x17, 0x1F, 0x15, 0x1A, 0x18, 0x11, 0x16, 0x1D, 0x10, 0x19, 0x13, 0x1E, 0x1B, 0x14, 0x12, 0x1C,
     0x47, 0x4F, 0x45, 0x4A, 0x48, 0x41, 0x46, 0x4D, 0x40, 0x49, 0x43, 0x4E, 0x4B, 0x44, 0x42, 0x4C,
     0x37, 0x3F, 0x35, 0x3A, 0x38, 0x31, 0x36, 0x3D, 0x30, 0x39, 0x33, 0x3E, 0x3B, 0x34, 0x32, 0x3C,
     0xE7, 0xEF, 0xE5, 0xEA, 0xE8, 0xE1, 0xE6, 0xED, 0xE0, 0xE9, 0xE3, 0xEE, 0xEB, 0xE4, 0xE2, 0xEC,
     0x07, 0x0F, 0x05, 0x0A, 0x08, 0x01, 0x06, 0x0D, 0x00, 0x09, 0x03, 0x0E, 0x0B, 0x04, 0x02, 0x0C,
    },
    {
     0x18, 0x1E, 0x12, 0x15, 0x16, 0x19, 0x11, 0x1C, 0x1F, 0x14, 0x1B, 0x10, 0x1D, 0x1A, 0x13, 0x17,
     0x78, 0x7E, 0x72, 0x75, 0x76, 0x79, 0x71, 0x7C, 0x7F, 0x74, 0x7B, 0x70, 0x7D, 0x7A, 0x73, 0x77,
     0xE8, 0xEE, 0xE2, 0xE5, 0xE6, 0xE9, 0xE1, 0xEC, 0xEF, 0xE4, 0xEB, 0xE0, 0xED, 0xEA, 0xE3, 0xE7,
     0xD8, 0xDE, 0xD2, 0xD5, 0xD6, 0xD9, 0xD1, 0xDC, 0xDF, 0xD4, 0xDB, 0xD0, 0xDD, 0xDA, 0xD3, 0xD7,
     0x08, 0x0E, 0x02, 0x05, 0x06, 0x09, 0x01, 0x0C, 0x0F, 0x04, 0x0B, 0x00, 0x0D, 0x0A, 0x03, 0x07,
     0x58, 0x5E, 0x52, 0x55, 0x56, 0x59, 0x51, 0x5C, 0x5F, 0x54, 0x5B, 0x50, 0x5D, 0x5A, 0x53, 0x57,
     0x88, 0x8E, 0x82, 0x85, 0x86, 0x89, 0x81, 0x8C, 0x8F, 0x84, 0x8B, 0x80, 0x8D, 0x8A, 0x83, 0x87,
     0x38, 0x3E, 0x32, 0x35, 0x36, 0x39, 0x31, 0x3C, 0x3F, 0x34, 0x3B, 0x30, 0x3D, 0x3A, 0x33, 0x37,
     0x48, 0x4E, 0x42, 0x45, 0x46, 0x49, 0x41, 0x4C, 0x4F, 0x44, 0x4B, 0x40, 0x4D, 0x4A, 0x43, 0x47,
     0xF8, 0xFE, 0xF2, 0xF5, 0xF6, 0xF9, 0xF1, 0xFC, 0xFF, 0xF4, 0xFB, 0xF0, 0xFD, 0xFA, 0xF3, 0xF7,
     0xA8, 0xAE, 0xA2, 0xA5, 0xA6, 0xA9, 0xA1, 0xAC, 0xAF, 0xA4, 0xAB, 0xA0, 0xAD, 0xAA, 0xA3, 0xA7,
     0x68, 0x6E, 0x62, 0x65, 0x66, 0x69, 0x61, 0x6C, 0x6F, 0x64, 0x6B, 0x60, 0x6D, 0x6A, 0x63, 0x67,
     0x98, 0x9E, 0x92, 0x95, 0x96, 0x99, 0x91, 0x9C, 0x9F, 0x94, 0x9B, 0x90, 0x9D, 0x9A, 0x93, 0x97,
     0xC8, 0xCE, 0xC2, 0xC5, 0xC6, 0xC9, 0xC1, 0xCC, 0xCF, 0xC4, 0xCB, 0xC0, 0xCD, 0xCA, 0xC3, 0xC7,
     0xB8, 0xBE, 0xB2, 0xB5, 0xB6, 0xB9, 0xB1, 0xBC, 0xBF, 0xB4, 0xBB, 0xB0, 0xBD, 0xBA, 0xB3, 0xB7,
     0x28, 0x2E, 0x22, 0x25, 0x26, 0x29, 0x21, 0x2C, 0x2F, 0x24, 0x2B, 0x20, 0x2D, 0x2A, 0x23, 0x27,
    }
  },
  {
    {
     0x93, 0x9B, 0x99, 0x9D, 0x95, 0x9A, 0x94, 0x96, 0x91, 0x97, 0x92, 0x98, 0x9F, 0x9C, 0x90, 0x9E,
     0x73, 0x7B, 0x79, 0x7D, 0x75, 0x7A, 0x74, 0x76, 0x71, 0x77, 0x72, 0x78, 0x7F, 0x7C, 0x70, 0x7E,
     0xD3, 0xDB, 0xD9, 0xDD, 0xD5, 0xDA, 0xD4, 0xD6, 0xD1, 0xD7, 0xD2, 0xD8, 0xDF, 0xDC, 0xD0, 0xDE,
     0xC3, 0xCB, 0xC9, 0xCD, 0xC5, 0xCA, 0xC4, 0xC6, 0xC1, 0xC7, 0xC2, 0xC8, 0xCF, 0xCC, 0xC0, 0xCE,
     0x63, 0x6B, 0x69, 0x6D, 0x65, 0x6A, 0x64, 0x66, 0x61, 0x67, 0x62, 0x68, 0x6F, 0x6C, 0x60, 0x6E,
     0x53, 0x5B, 0x59, 0x5D, 0x55, 0x5A, 0x54, 0x56, 0x51, 0x57, 0x52, 0x58, 0x5F, 0x5C, 0x50, 0x5E,
     0xA3, 0xAB, 0xA9, 0xAD, 0xA5, 0xAA, 0xA4, 0xA6, 0xA1, 0xA7, 0xA2, 0xA8, 0xAF, 0xAC, 0xA0, 0xAE,
     0x33, 0x3B, 0x39, 0x3D, 0x35, 0x3A, 0x34, 0x36, 0x31, 0x37, 0x32, 0x38, 0x3F, 0x3C, 0x30, 0x3E,
     0xE3, 0xEB, 0xE9, 0xED, 0xE5, 0xEA, 0xE4, 0xE6, 0xE1, 0xE7, 0xE2, 0xE8, 0xEF, 0xEC, 0xE0, 0xEE,
     0x13, 0x1B, 0x19, 0x1D, 0x15, 0x1A, 0x14, 0x16, 0x11, 0x17, 0x12, 0x18, 0x1F, 0x1C, 0x10, 0x1E,
     0xB3, 0xBB, 0xB9, 0xBD, 0xB5, 0xBA, 0xB4, 0xB6, 0xB1, 0xB7, 0xB2, 0xB8, 0xBF, 0xBC, 0xB0, 0xBE,
     0x83, 0x8B, 0x89, 0x8D, 0x85, 0x8A, 0x84, 0x86, 0x81, 0x87, 0x82, 0x88, 0x8F, 0x8C, 0x80, 0x8E,
     0x43, 0x4B, 0x49, 0x4D, 0x45, 0x4A, 0x44, 0x46, 0x41, 0x47, 0x42, 0x48, 0x4F, 0x4C, 0x40, 0x4E,
     0x23, 0x2B, 0x29, 0x2D, 0x25, 0x2A, 0x24, 0x26, 0x21, 0x27, 0x22, 0x28, 0x2F, 0x2C, 0x20, 0x2E,
     0xF3, 0xFB, 0xF9, 0xFD, 0xF5, 0xFA, 0xF4, 0xF6, 0xF1, 0xF7, 0xF2, 0xF8, 0xFF, 0xFC, 0xF0, 0xFE,
     0x03, 0x0B, 0x09, 0x0D, 0x05, 0x0A, 0x04, 0x06, 0x01, 0x07, 0x02, 0x08, 0x0F, 0x0C, 0x00, 0x0E,
    },
    {
     0x34, 0x3C, 0x3A, 0x37, 0x3D, 0x30, 0x35, 0x32, 0x31, 0x3E, 0x38, 0x3B, 0x33, 0x36, 0x39, 0x3F,
     0x74, 0x7C, 0x7A, 0x77, 0x7D, 0x70, 0x75, 0x72, 0x71, 0x7E, 0x78, 0x7B, 0x73, 0x76, 0x79, 0x7F,
     0xD4, 0xDC, 0xDA, 0xD7, 0xDD, 0xD0, 0xD5, 0xD2, 0xD1, 0xDE, 0xD8, 0xDB, 0xD3, 0xD6, 0xD9, 0xDF,
     0xE4, 0xEC, 0xEA, 0xE7, 0xED, 0xE0, 0xE5, 0xE2, 0xE1, 0xEE, 0xE8, 0xEB, 0xE3, 0xE6, 0xE9, 0xEF,
     0x24, 0x2C, 0x2A, 0x27, 0x2D, 0x20, 0x25, 0x22, 0x21, 0x2E, 0x28, 0x2B, 0x23, 0x26, 0x29, 0x2F,
     0xB4, 0xBC, 0xBA, 0xB7, 0xBD, 0xB0, 0xB5, 0xB2, 0xB1, 0xBE, 0xB8, 0xBB, 0xB3, 0xB6, 0xB9, 0xBF,
     0x04, 0x0C, 0x0A, 0x07, 0x0D, 0x00, 0x05, 0x02, 0x01, 0x0E, 0x08, 0x0B, 0x03, 0x06, 0x09, 0x0F,
     0x94, 0x9C, 0x9A, 0x97, 0x9D, 0x90, 0x95, 0x92, 0x91, 0x9E, 0x98, 0x9B, 0x93, 0x96, 0x99, 0x9F,
     0x84, 0x8C, 0x8A, 0x87, 0x8D, 0x80, 0x85, 0x82, 0x81, 0x8E, 0x88, 0x8B, 0x83, 0x86, 0x89, 0x8F,
     0xF4, 0xFC, 0xFA, 0xF7, 0xFD, 0xF0, 0xF5, 0xF2, 0xF1, 0xFE, 0xF8, 0xFB, 0xF3, 0xF6, 0xF9, 0xFF,
     0x54, 0x5C, 0x5A, 0x57, 0x5D, 0x50, 0x55, 0x52, 0x51, 0x5E, 0x58, 0x5B, 0x53, 0x56, 0x59, 0x5F,
     0xA4, 0xAC, 0xAA, 0xA7, 0xAD, 0xA0, 0xA5, 0xA2, 0xA1, 0xAE, 0xA8, 0xAB, 0xA3, 0xA6, 0xA9, 0xAF,
     0xC4, 0xCC, 0xCA, 0xC7, 0xCD, 0xC0, 0xC5, 0xC2, 0xC1, 0xCE, 0xC8, 0xCB, 0xC3, 0xC6, 0xC9, 0xCF,
     0x14, 0x1C, 0x1A, 0x17, 0x1D, 0x10, 0x15, 0x12, 0x11, 0x1E, 0x18, 0x1B, 0x13, 0x16, 0x19, 0x1F,
     0x64, 0x6C, 0x6A, 0x67, 0x6D, 0x60, 0x65, 0x62, 0x61, 0x6E, 0x68, 0x6B, 0x63, 0x66, 0x69, 0x6F,
     0x44, 0x4C, 0x4A, 0x47, 0x4D, 0x40, 0x45, 0x42, 0x41, 0x4E, 0x48, 0x4B, 0x43, 0x46, 0x49, 0x4F,
    },
    {
     0xA8, 0xA0, 0xAA, 0xA5, 0xA7, 0xAE, 0xA9, 0xA2, 0xAF, 0xA6, 0xAC, 0xA1, 0xA4, 0xAB, 0xAD, 0xA3,
     0x28, 0x20, 0x2A, 0x25, 0x27, 0x2E, 0x29, 0x22, 0x2F, 0x26, 0x2C, 0x21, 0x24, 0x2B, 0x2D, 0x23,
     0x08, 0x00, 0x0A, 0x05, 0x07, 0x0E, 0x09, 0x02, 0x0F, 0x06, 0x0C, 0x01, 0x04, 0x0B, 0x0D, 0x03,
     0x98, 0x90, 0x9A, 0x95, 0x97, 0x9E, 0x99, 0x92, 0x9F, 0x96, 0x9C, 0x91, 0x94, 0x9B, 0x9D, 0x93,
     0x68, 0x60, 0x6A, 0x65, 0x67, 0x6E, 0x69, 0x62, 0x6F, 0x66, 0x6C, 0x61, 0x64, 0x6B, 0x6D, 0x63,
     0xD8, 0xD0, 0xDA, 0xD5, 0xD7, 0xDE, 0xD9, 0xD2, 0xDF, 0xD6, 0xDC, 0xD1, 0xD4, 0xDB, 0xDD, 0xD3,
     0x38, 0x30, 0x3A, 0x35, 0x37, 0x3E, 0x39, 0x32, 0x3F, 0x36, 0x3C, 0x31, 0x34, 0x3B, 0x3D, 0x33,
     0x58, 0x50, 0x5A, 0x55, 0x57, 0x5E, 0x59, 0x52, 0x5F, 0x56, 0x5C, 0x51, 0x54, 0x5B, 0x5D, 0x53,
     0x48, 0x40, 0x4A, 0x45, 0x47, 0x4E, 0x49, 0x42, 0x4F, 0x46, 0x4C, 0x41, 0x44, 0x4B, 0x4D, 0x43,
     0x88, 0x80, 0x8A, 0x85, 0x87, 0x8E, 0x89, 0x82, 0x8F, 0x86, 0x8C, 0x81, 0x84, 0x8B, 0x8D, 0x83,
     0x78, 0x70, 0x7A, 0x75, 0x77, 0x7E, 0x79, 0x72, 0x7F, 0x76, 0x7C, 0x71, 0x74, 0x7B, 0x7D, 0x73,
     0xE8, 0xE0, 0xEA, 0xE5, 0xE7, 0xEE, 0xE9, 0xE2, 0xEF, 0xE6, 0xEC, 0xE1, 0xE4, 0xEB, 0xED, 0xE3,
     0xB8, 0xB0, 0xBA, 0xB5, 0xB7, 0xBE, 0xB9, 0xB2, 0xBF, 0xB6, 0xBC, 0xB1, 0xB4, 0xBB, 0xBD, 0xB3,
     0xC8, 0xC0, 0xCA, 0xC5, 0xC7, 0xCE, 0xC9, 0xC2, 0xCF, 0xC6, 0xCC, 0xC1, 0xC4, 0xCB, 0xCD, 0xC3,
     0x18, 0x10, 0x1A, 0x15, 0x17, 0x1E, 0x19, 0x12, 0x1F, 0x16, 0x1C, 0x11, 0x14, 0x1B, 0x1D, 0x13,
     0xF8, 0xF0, 0xFA, 0xF5, 0xF7, 0xFE, 0xF9, 0xF2, 0xFF, 0xF6, 0xFC, 0xF1, 0xF4, 0xFB, 0xFD, 0xF3,
    },
    {
     0xE7, 0xE1, 0xED, 0xEA, 0xE9, 0xE6, 0xEE, 0xE3, 0xE0, 0xEB, 0xE4, 0xEF, 0xE2, 0xE5, 0xEC, 0xE8,
     0x87, 0x81, 0x8D, 0x8A, 0x89, 0x86, 0x8E, 0x83, 0x80, 0x8B, 0x84, 0x8F, 0x82, 0x85, 0x8C, 0x88,
     0x17, 0x11, 0x1D, 0x1A, 0x19, 0x16, 0x1E, 0x13, 0x10, 0x1B, 0x14, 0x1F, 0x12, 0x15, 0x1C, 0x18,
     0x27, 0x21, 0x2D, 0x2A, 0x29, 0x26, 0x2E, 0x23, 0x20, 0x2B, 0x24, 0x2F, 0x22, 0x25, 0x2C, 0x28,
     0xF7, 0xF1, 0xFD, 0xFA, 0xF9, 0xF6, 0xFE, 0xF3, 0xF0, 0xFB, 0xF4, 0xFF, 0xF2, 0xF5, 0xFC, 0xF8,
     0xA7, 0xA1, 0xAD, 0xAA, 0xA9, 0xA6, 0xAE, 0xA3, 0xA0, 0xAB, 0xA4, 0xAF, 0xA2, 0xA5, 0xAC, 0xA8,
     0x77, 0x71, 0x7D, 0x7A, 0x79, 0x76, 0x7E, 0x73, 0x70, 0x7B, 0x74, 0x7F, 0x72, 0x75, 0x7C, 0x78,
     0xC7, 0xC1, 0xCD, 0xCA, 0xC9, 0xC6, 0xCE, 0xC3, 0xC0, 0xCB, 0xC4, 0xCF, 0xC2, 0xC5, 0xCC, 0xC8,
     0xB7, 0xB1, 0xBD, 0xBA, 0xB9, 0xB6, 0xBE, 0xB3, 0xB0, 0xBB, 0xB4, 0xBF, 0xB2, 0xB5, 0xBC, 0xB8,
     0x07, 0x01, 0x0D, 0x0A, 0x09, 0x06, 0x0E, 0x03, 0x00, 0x0B, 0x04, 0x0F, 0x02, 0x05, 0x0C, 0x08,
     0x57, 0x51, 0x5D, 0x5A, 0x59, 0x56, 0x5E, 0x53, 0x50, 0x5B, 0x54, 0x5F, 0x52, 0x55, 0x5C, 0x58,
     0x97, 0x91, 0x9D, 0x9A, 0x99, 0x96, 0x9E, 0x93, 0x90, 0x9B, 0x94, 0x9F, 0x92, 0x95, 0x9C, 0x98,
     0x67, 0x61, 0x6D, 0x6A, 0x69, 0x66, 0x6E, 0x63, 0x60, 0x6B, 0x64, 0x6F, 0x62, 0x65, 0x6C, 0x68,
     0x37, 0x31, 0x3D, 0x3A, 0x39, 0x36, 0x3E, 0x33, 0x30, 0x3B, 0x34, 0x3F, 0x32, 0x35, 0x3C, 0x38,
     0x47, 0x41, 0x4D, 0x4A, 0x49, 0x46, 0x4E, 0x43, 0x40, 0x4B, 0x44, 0x4F, 0x42, 0x45, 0x4C, 0x48,
     0xD7, 0xD1, 0xDD, 0xDA, 0xD9, 0xD6, 0xDE, 0xD3, 0xD0, 0xDB, 0xD4, 0xDF, 0xD2, 0xD5, 0xDC, 0xD8,
    }
   }
  },
  {
   {
    {
     0xF1, 0xFF, 0xF3, 0xF0, 0xF7, 0xFD, 0xF8, 0xFE, 0xF9, 0xFB, 0xF5, 0xFA, 0xF2, 0xF6, 0xF4, 0xFC,
     0x01, 0x0F, 0x03, 0x00, 0x07, 0x0D, 0x08, 0x0E, 0x09, 0x0B, 0x05, 0x0A, 0x02, 0x06, 0x04, 0x0C,
     0xD1, 0xDF, 0xD3, 0xD0, 0xD7, 0xDD, 0xD8, 0xDE, 0xD9, 0xDB, 0xD5, 0xDA, 0xD2, 0xD6, 0xD4, 0xDC,
     0xB1, 0xBF, 0xB3, 0xB0, 0xB7, 0xBD, 0xB8, 0xBE, 0xB9, 0xBB, 0xB5, 0xBA, 0xB2, 0xB6, 0xB4, 0xBC,
     0x71, 0x7F, 0x73, 0x70, 0x77, 0x7D, 0x78, 0x7E, 0x79, 0x7B, 0x75, 0x7A, 0x72, 0x76, 0x74, 0x7C,
     0x41, 0x4F, 0x43, 0x40, 0x47, 0x4D, 0x48, 0x4E, 0x49, 0x4B, 0x45, 0x4A, 0x42, 0x46, 0x44, 0x4C,
     0xE1, 0xEF, 0xE3, 0xE0, 0xE7, 0xED, 0xE8, 0xEE, 0xE9, 0xEB, 0xE5, 0xEA, 0xE2, 0xE6, 0xE4, 0xEC,
     0x11, 0x1F, 0x13, 0x10, 0x17, 0x1D, 0x18, 0x1E, 0x19, 0x1B, 0x15, 0x1A, 0x12, 0x16, 0x14, 0x1C,
     0xC1, 0xCF, 0xC3, 0xC0, 0xC7, 0xCD, 0xC8, 0xCE, 0xC9, 0xCB, 0xC5, 0xCA, 0xC2, 0xC6, 0xC4, 0xCC,
     0x51, 0x5F, 0x53, 0x50, 0x57, 0x5D, 0x58, 0x5E, 0x59, 0x5B, 0x55, 0x5A, 0x52, 0x56, 0x54, 0x5C,
     0xA1, 0xAF, 0xA3, 0xA0, 0xA7, 0xAD, 0xA8, 0xAE, 0xA9, 0xAB, 0xA5, 0xAA, 0xA2, 0xA6, 0xA4, 0xAC,
     0x91, 0x9F, 0x93, 0x90, 0x97, 0x9D, 0x98, 0x9E, 0x99, 0x9B, 0x95, 0x9A, 0x92, 0x96, 0x94, 0x9C,
     0x31, 0x3F, 0x33, 0x30, 0x37, 0x3D, 0x38, 0x3E, 0x39, 0x3B, 0x35, 0x3A, 0x32, 0x36, 0x34, 0x3C,
     0x21, 0x2F, 0x23, 0x20, 0x27, 0x2D, 0x28, 0x2E, 0x29, 0x2B, 0x25, 0x2A, 0x22, 0x26, 0x24, 0x2C,
     0x81, 0x8F, 0x83, 0x80, 0x87, 0x8D, 0x88, 0x8E, 0x89, 0x8B, 0x85, 0x8A, 0x82, 0x86, 0x84, 0x8C,
     0x61, 0x6F, 0x63, 0x60, 0x67, 0x6D, 0x68, 0x6E, 0x69, 0x6B, 0x65, 0x6A, 0x62, 0x66, 0x64, 0x6C,
    },
    {
     0xB0, 0xB6, 0xB9, 0xBC, 0xB4, 0xB7, 0xB1, 0xBE, 0xBD, 0xBA, 0xBF, 0xB2, 0xB8, 0xB5, 0xB3, 0xBB,
     0x90, 0x96, 0x99, 0x9C, 0x94, 0x97, 0x91, 0x9E, 0x9D, 0x9A, 0x9F, 0x92, 0x98, 0x95, 0x93, 0x9B,
     0xE0, 0xE6, 0xE9, 0xEC, 0xE4, 0xE7, 0xE1, 0xEE, 0xED, 0xEA, 0xEF, 0xE2, 0xE8, 0xE5, 0xE3, 0xEB,
     0x30, 0x36, 0x39, 0x3C, 0x34, 0x37, 0x31, 0x3E, 0x3D, 0x3A, 0x3F, 0x32, 0x38, 0x35, 0x33, 0x3B,
     0x50, 0x56, 0x59, 0x5C, 0x54, 0x57, 0x51, 0x5E, 0x5D, 0x5A, 0x5F, 0x52, 0x58, 0x55, 0x53, 0x5B,
     0xA0, 0xA6, 0xA9, 0xAC, 0xA4, 0xA7, 0xA1, 0xAE, 0xAD, 0xAA, 0xAF, 0xA2, 0xA8, 0xA5, 0xA3, 0xAB,
     0x00, 0x06, 0x09, 0x0C, 0x04, 0x07, 0x01, 0x0E, 0x0D, 0x0A, 0x0F, 0x02, 0x08, 0x05, 0x03, 0x0B,
     0x70, 0x76, 0x79, 0x7C, 0x74, 0x77, 0x71, 0x7E, 0x7D, 0x7A, 0x7F, 0x72, 0x78, 0x75, 0x73, 0x7B,
     0x60, 0x66, 0x69, 0x6C, 0x64, 0x67, 0x61, 0x6E, 0x6D, 0x6A, 0x6F, 0x62, 0x68, 0x65, 0x63, 0x6B,
     0xF0, 0xF6, 0xF9, 0xFC, 0xF4, 0xF7, 0xF1, 0xFE, 0xFD, 0xFA, 0xFF, 0xF2, 0xF8, 0xF5, 0xF3, 0xFB,
     0x40, 0x46, 0x49, 0x4C, 0x44, 0x47, 0x41, 0x4E, 0x4D, 0x4A, 0x4F, 0x42, 0x48, 0x45, 0x43, 0x4B,
     0xD0, 0xD6, 0xD9, 0xDC, 0xD4, 0xD7, 0xD1, 0xDE, 0xDD, 0xDA, 0xDF, 0xD2, 0xD8, 0xD5, 0xD3, 0xDB,
     0x10, 0x16, 0x19, 0x1C, 0x14, 0x17, 0x11, 0x1E, 0x1D, 0x1A, 0x1F, 0x12, 0x18, 0x15, 0x13, 0x1B,
     0x20, 0x26, 0x29, 0x2C, 0x24, 0x27, 0x21, 0x2E, 0x2D, 0x2A, 0x2F, 0x22, 0x28, 0x25, 0x23, 0x2B,
     0x80, 0x86, 0x89, 0x8C, 0x84, 0x87, 0x81, 0x8E, 0x8D, 0x8A, 0x8F, 0x82, 0x88, 0x85, 0x83, 0x8B,
     0xC0, 0xC6, 0xC9, 0xCC, 0xC4, 0xC7, 0xC1, 0xCE, 0xCD, 0xCA, 0xCF, 0xC2, 0xC8, 0xC5, 0xC3, 0xCB,
    },
    {
     0x0C, 0x02, 0x04, 0x0B, 0x0E, 0x03, 0x09, 0x00, 0x0D, 0x06, 0x01, 0x08, 0x0A, 0x05, 0x0F, 0x07,
     0xEC, 0xE2, 0xE4, 0xEB, 0xEE, 0xE3, 0xE9, 0xE0, 0xED, 0xE6, 0xE1, 0xE8, 0xEA, 0xE5, 0xEF, 0xE7,
     0x3C, 0x32, 0x34, 0x3B, 0x3E, 0x33, 0x39, 0x30, 0x3D, 0x36, 0x31, 0x38, 0x3A, 0x35, 0x3F, 0x37,
     0x4C, 0x42, 0x44, 0x4B, 0x4E, 0x43, 0x49, 0x40, 0x4D, 0x46, 0x41, 0x48, 0x4A, 0x45, 0x4F, 0x47,
     0x1C, 0x12, 0x14, 0x1B, 0x1E, 0x13, 0x19, 0x10, 0x1D, 0x16, 0x11, 0x18, 0x1A, 0x15, 0x1F, 0x17,
     0x8C, 0x82, 0x84, 0x8B, 0x8E, 0x83, 0x89, 0x80, 0x8D, 0x86, 0x81, 0x88, 0x8A, 0x85, 0x8F, 0x87,
     0x7C, 0x72, 0x74, 0x7B, 0x7E, 0x73, 0x79, 0x70, 0x7D, 0x76, 0x71, 0x78, 0x7A, 0x75, 0x7F, 0x77,
     0xBC, 0xB2, 0xB4, 0xBB, 0xBE, 0xB3, 0xB9, 0xB0, 0xBD, 0xB6, 0xB1, 0xB8, 0xBA, 0xB5, 0xBF, 0xB7,
     0xAC, 0xA2, 0xA4, 0xAB, 0xAE, 0xA3, 0xA9, 0xA0, 0xAD, 0xA6, 0xA1, 0xA8, 0xAA, 0xA5, 0xAF, 0xA7,
     0xCC, 0xC2, 0xC4, 0xCB, 0xCE, 0xC3, 0xC9, 0xC0, 0xCD, 0xC6, 0xC1, 0xC8, 0xCA, 0xC5, 0xCF, 0xC7,
     0x2C, 0x22, 0x24, 0x2B, 0x2E, 0x23, 0x29, 0x20, 0x2D, 0x26, 0x21, 0x28, 0x2A, 0x25, 0x2F, 0x27,
     0x9C, 0x92, 0x94, 0x9B, 0x9E, 0x93, 0x99, 0x90, 0x9D, 0x96, 0x91, 0x98, 0x9A, 0x95, 0x9F, 0x97,
     0x6C, 0x62, 0x64, 0x6B, 0x6E, 0x63, 0x69, 0x60, 0x6D, 0x66, 0x61, 0x68, 0x6A, 0x65, 0x6F, 0x67,
     0xFC, 0xF2, 0xF4, 0xFB, 0xFE, 0xF3, 0xF9, 0xF0, 0xFD, 0xF6, 0xF1, 0xF8, 0xFA, 0xF5, 0xFF, 0xF7,
     0xDC, 0xD2, 0xD4, 0xDB, 0xDE, 0xD3, 0xD9, 0xD0, 0xDD, 0xD6, 0xD1, 0xD8, 0xDA, 0xD5, 0xDF, 0xD7,
     0x5C, 0x52, 0x54, 0x5B, 0x5E, 0x53, 0x59, 0x50, 0x5D, 0x56, 0x51, 0x58, 0x5A, 0x55, 0x5F, 0x57,
    },
    {
     0x27, 0x23, 0x2A, 0x2D, 0x20, 0x2B, 0x24, 0x2F, 0x2C, 0x21, 0x29, 0x26, 0x25, 0x22, 0x2E, 0x28,
     0xB7, 0xB3, 0xBA, 0xBD, 0xB0, 0xBB, 0xB4, 0xBF, 0xBC, 0xB1, 0xB9, 0xB6, 0xB5, 0xB2, 0xBE, 0xB8,
     0xC7, 0xC3, 0xCA, 0xCD, 0xC0, 0xCB, 0xC4, 0xCF, 0xCC, 0xC1, 0xC9, 0xC6, 0xC5, 0xC2, 0xCE, 0xC8,
     0x97, 0x93, 0x9A, 0x9D, 0x90, 0x9B, 0x94, 0x9F, 0x9C, 0x91, 0x99, 0x96, 0x95, 0x92, 0x9E, 0x98,
     0x67, 0x63, 0x6A, 0x6D, 0x60, 0x6B, 0x64, 0x6F, 0x6C, 0x61, 0x69, 0x66, 0x65, 0x62, 0x6E, 0x68,
     0xA7, 0xA3, 0xAA, 0xAD, 0xA0, 0xAB, 0xA4, 0xAF, 0xAC, 0xA1, 0xA9, 0xA6, 0xA5, 0xA2, 0xAE, 0xA8,
     0xF7, 0xF3, 0xFA, 0xFD, 0xF0, 0xFB, 0xF4, 0xFF, 0xFC, 0xF1, 0xF9, 0xF6, 0xF5, 0xF2, 0xFE, 0xF8,
     0x47, 0x43, 0x4A, 0x4D, 0x40, 0x4B, 0x44, 0x4F, 0x4C, 0x41, 0x49, 0x46, 0x45, 0x42, 0x4E, 0x48,
     0x37, 0x33, 0x3A, 0x3D, 0x30, 0x3B, 0x34, 0x3F, 0x3C, 0x31, 0x39, 0x36, 0x35, 0x32, 0x3E, 0x38,
     0x87, 0x83, 0x8A, 0x8D, 0x80, 0x8B, 0x84, 0x8F, 0x8C, 0x81, 0x89, 0x86, 0x85, 0x82, 0x8E, 0x88,
     0x57, 0x53, 0x5A, 0x5D, 0x50, 0x5B, 0x54, 0x5F, 0x5C, 0x51, 0x59, 0x56, 0x55, 0x52, 0x5E, 0x58,
     0x07, 0x03, 0x0A, 0x0D, 0x00, 0x0B, 0x04, 0x0F, 0x0C, 0x01, 0x09, 0x06, 0x05, 0x02, 0x0E, 0x08,
     0xD7, 0xD3, 0xDA, 0xDD, 0xD0, 0xDB, 0xD4, 0xDF, 0xDC, 0xD1, 0xD9, 0xD6, 0xD5, 0xD2, 0xDE, 0xD8,
     0xE7, 0xE3, 0xEA, 0xED, 0xE0, 0xEB, 0xE4, 0xEF, 0xEC, 0xE1, 0xE9, 0xE6, 0xE5, 0xE2, 0xEE, 0xE8,
     0x77, 0x73, 0x7A, 0x7D, 0x70, 0x7B, 0x74, 0x7F, 0x7C, 0x71, 0x79, 0x76, 0x75, 0x72, 0x7E, 0x78,
     0x17, 0x13, 0x1A, 0x1D, 0x10, 0x1B, 0x14, 0x1F, 0x1C, 0x11, 0x19, 0x16, 0x15, 0x12, 0x1E, 0x18,
    }
   },
   {
    {
     0x0E, 0x00, 0x0C, 0x0F, 0x08, 0x02, 0x07, 0x01, 0x06, 0x04, 0x0A, 0x05, 0x0D, 0x09, 0x0B, 0x03,
     0xFE, 0xF0, 0xFC, 0xFF, 0xF8, 0xF2, 0xF7, 0xF1, 0xF6, 0xF4, 0xFA, 0xF5, 0xFD, 0xF9, 0xFB, 0xF3,
     0x2E, 0x20, 0x2C, 0x2F, 0x28, 0x22, 0x27, 0x21, 0x26, 0x24, 0x2A, 0x25, 0x2D, 0x29, 0x2B, 0x23,
     0x4E, 0x40, 0x4C, 0x4F, 0x48, 0x42, 0x47, 0x41, 0x46, 0x44, 0x4A, 0x45, 0x4D, 0x49, 0x4B, 0x43,
     0x8E, 0x80, 0x8C, 0x8F, 0x88, 0x82, 0x87, 0x81, 0x86, 0x84, 0x8A, 0x85, 0x8D, 0x89, 0x8B, 0x83,
     0xBE, 0xB0, 0xBC, 0xBF, 0xB8, 0xB2, 0xB7, 0xB1, 0xB6, 0xB4, 0xBA, 0xB5, 0xBD, 0xB9, 0xBB, 0xB3,
     0x1E, 0x10, 0x1C, 0x1F, 0x18, 0x12, 0x17, 0x11, 0x16, 0x14, 0x1A, 0x15, 0x1D, 0x19, 0x1B, 0x13,
     0xEE, 0xE0, 0xEC, 0xEF, 0xE8, 0xE2, 0xE7, 0xE1, 0xE6, 0xE4, 0xEA, 0xE5, 0xED, 0xE9, 0xEB, 0xE3,
     0x3E, 0x30, 0x3C, 0x3F, 0x38, 0x32, 0x37, 0x31, 0x36, 0x34, 0x3A, 0x35, 0x3D, 0x39, 0x3B, 0x33,
     0xAE, 0xA0, 0xAC, 0xAF, 0xA8, 0xA2, 0xA7, 0xA1, 0xA6, 0xA4, 0xAA, 0xA5, 0xAD, 0xA9, 0xAB, 0xA3,
     0x5E, 0x50, 0x5C, 0x5F, 0x58, 0x52, 0x57, 0x51, 0x56, 0x54, 0x5A, 0x55, 0x5D, 0x59, 0x5B, 0x53,
     0x6E, 0x60, 0x6C, 0x6F, 0x68, 0x62, 0x67, 0x61, 0x66, 0x64, 0x6A, 0x65, 0x6D, 0x69, 0x6B, 0x63,
     0xCE, 0xC0, 0xCC, 0xCF, 0xC8, 0xC2, 0xC7, 0xC1, 0xC6, 0xC4, 0xCA, 0xC5, 0xCD, 0xC9, 0xCB, 0xC3,
     0xDE, 0xD0, 0xDC, 0xDF, 0xD8, 0xD2, 0xD7, 0xD1, 0xD6, 0xD4, 0xDA, 0xD5, 0xDD, 0xD9, 0xDB, 0xD3,
     0x7E, 0x70, 0x7C, 0x7F, 0x78, 0x72, 0x77, 0x71, 0x76, 0x74, 0x7A, 0x75, 0x7D, 0x79, 0x7B, 0x73,
     0x9E, 0x90, 0x9C, 0x9F, 0x98, 0x92, 0x97, 0x91, 0x96, 0x94, 0x9A, 0x95, 0x9D, 0x99, 0x9B, 0x93,
    },
    {
     0x4F, 0x49, 0x46, 0x43, 0x4B, 0x48, 0x4E, 0x41, 0x42, 0x45, 0x40, 0x4D, 0x47, 0x4A, 0x4C, 0x44,
     0x6F, 0x69, 0x66, 0x63, 0x6B, 0x68, 0x6E, 0x61, 0x62, 0x65, 0x60, 0x6D, 0x67, 0x6A, 0x6C, 0x64,
     0x1F, 0x19, 0x16, 0x13, 0x1B, 0x18, 0x1E, 0x11, 0x12, 0x15, 0x10, 0x1D, 0x17, 0x1A, 0x1C, 0x14,
     0xCF, 0xC9, 0xC6, 0xC3, 0xCB, 0xC8, 0xCE, 0xC1, 0xC2, 0xC5, 0xC0, 0xCD, 0xC7, 0xCA, 0xCC, 0xC4,
     0xAF, 0xA9, 0xA6, 0xA3, 0xAB, 0xA8, 0xAE, 0xA1, 0xA2, 0xA5, 0xA0, 0xAD, 0xA7, 0xAA, 0xAC, 0xA4,
     0x5F, 0x59, 0x56, 0x53, 0x5B, 0x58, 0x5E, 0x51, 0x52, 0x55, 0x50, 0x5D, 0x57, 0x5A, 0x5C, 0x54,
     0xFF, 0xF9, 0xF6, 0xF3, 0xFB, 0xF8, 0xFE, 0xF1, 0xF2, 0xF5, 0xF0, 0xFD, 0xF7, 0xFA, 0xFC, 0xF4,
     0x8F, 0x89, 0x86, 0x83, 0x8B, 0x88, 0x8E, 0x81, 0x82, 0x85, 0x80, 0x8D, 0x87, 0x8A, 0x8C, 0x84,
     0x9F, 0x99, 0x96, 0x93, 0x9B, 0x98, 0x9E, 0x91, 0x92, 0x95, 0x90, 0x9D, 0x97, 0x9A, 0x9C, 0x94,
     0x0F, 0x09, 0x06, 0x03, 0x0B, 0x08, 0x0E, 0x01, 0x02, 0x05, 0x00, 0x0D, 0x07, 0x0A, 0x0C, 0x04,
     0xBF, 0xB9, 0xB6, 0xB3, 0xBB, 0xB8, 0xBE, 0xB1, 0xB2, 0xB5, 0xB0, 0xBD, 0xB7, 0xBA, 0xBC, 0xB4,
     0x2F, 0x29, 0x26, 0x23, 0x2B, 0x28, 0x2E, 0x21, 0x22, 0x25, 0x20, 0x2D, 0x27, 0x2A, 0x2C, 0x24,
     0xEF, 0xE9, 0xE6, 0xE3, 0xEB, 0xE8, 0xEE, 0xE1, 0xE2, 0xE5, 0xE0, 0xED, 0xE7, 0xEA, 0xEC, 0xE4,
     0xDF, 0xD9, 0xD6, 0xD3, 0xDB, 0xD8, 0xDE, 0xD1, 0xD2, 0xD5, 0xD0, 0xDD, 0xD7, 0xDA, 0xDC, 0xD4,
     0x7F, 0x79, 0x76, 0x73, 0x7B, 0x78, 0x7E, 0x71, 0x72, 0x75, 0x70, 0x7D, 0x77, 0x7A, 0x7C, 0x74,
     0x3F, 0x39, 0x36, 0x33, 0x3B, 0x38, 0x3E, 0x31, 0x32, 0x35, 0x30, 0x3D, 0x37, 0x3A, 0x3C, 0x34,
    },
    {
     0xF3, 0xFD, 0xFB, 0xF4, 0xF1, 0xFC, 0xF6, 0xFF, 0xF2, 0xF9, 0xFE, 0xF7, 0xF5, 0xFA, 0xF0, 0xF8,
     0x13, 0x1D, 0x1B, 0x14, 0x11, 0x1C, 0x16, 0x1F, 0x12, 0x19, 0x1E, 0x17, 0x15, 0x1A, 0x10, 0x18,
     0xC3, 0xCD, 0xCB, 0xC4, 0xC1, 0xCC, 0xC6, 0xCF, 0xC2, 0xC9, 0xCE, 0xC7, 0xC5, 0xCA, 0xC0, 0xC8,
     0xB3, 0xBD, 0xBB, 0xB4, 0xB1, 0xBC, 0xB6, 0xBF, 0xB2, 0xB9, 0xBE, 0xB7, 0xB5, 0xBA, 0xB0, 0xB8,
     0xE3, 0xED, 0xEB, 0xE4, 0xE1, 0xEC, 0xE6, 0xEF, 0xE2, 0xE9, 0xEE, 0xE7, 0xE5, 0xEA, 0xE0, 0xE8,
     0x73, 0x7D, 0x7B, 0x74, 0x71, 0x7C, 0x76, 0x7F, 0x72, 0x79, 0x7E, 0x77, 0x75, 0x7A, 0x70, 0x78,
     0x83, 0x8D, 0x8B, 0x84, 0x81, 0x8C, 0x86, 0x8F, 0x82, 0x89, 0x8E, 0x87, 0x85, 0x8A, 0x80, 0x88,
     0x43, 0x4D, 0x4B, 0x44, 0x41, 0x4C, 0x46, 0x4F, 0x42, 0x49, 0x4E, 0x47, 0x45, 0x4A, 0x40, 0x48,
     0x53, 0x5D, 0x5B, 0x54, 0x51, 0x5C, 0x56, 0x5F, 0x52, 0x59, 0x5E, 0x57, 0x55, 0x5A, 0x50, 0x58,
     0x33, 0x3D, 0x3B, 0x34, 0x31, 0x3C, 0x36, 0x3F, 0x32, 0x39, 0x3E, 0x37, 0x35, 0x3A, 0x30, 0x38,
     0xD3, 0xDD, 0xDB, 0xD4, 0xD1, 0xDC, 0xD6, 0xDF, 0xD2, 0xD9, 0xDE, 0xD7, 0xD5, 0xDA, 0xD0, 0xD8,
     0x63, 0x6D, 0x6B, 0x64, 0x61, 0x6C, 0x66, 0x6F, 0x62, 0x69, 0x6E, 0x67, 0x65, 0x6A, 0x60, 0x68,
     0x93, 0x9D, 0x9B, 0x94, 0x91, 0x9C, 0x96, 0x9F, 0x92, 0x99, 0x9E, 0x97, 0x95, 0x9A, 0x90, 0x98,
     0x03, 0x0D, 0x0B, 0x04, 0x01, 0x0C, 0x06, 0x0F, 0x02, 0x09, 0x0E, 0x07, 0x05, 0x0A, 0x00, 0x08,
     0x23, 0x2D, 0x2B, 0x24, 0x21, 0x2C, 0x26, 0x2F, 0x22, 0x29, 0x2E, 0x27, 0x25, 0x2A, 0x20, 0x28,
     0xA3, 0xAD, 0xAB, 0xA4, 0xA1, 0xAC, 0xA6, 0xAF, 0xA2, 0xA9, 0xAE, 0xA7, 0xA5, 0xAA, 0xA0, 0xA8,
    },
    {
     0xD8, 0xDC, 0xD5, 0xD2, 0xDF, 0xD4, 0xDB, 0xD0, 0xD3, 0xDE, 0xD6, 0xD9, 0xDA, 0xDD, 0xD1, 0xD7,
     0x48, 0x4C, 0x45, 0x42, 0x4F, 0x44, 0x4B, 0x40, 0x43, 0x4E, 0x46, 0x49, 0x4A, 0x4D, 0x41, 0x47,
     0x38, 0x3C, 0x35, 0x32, 0x3F, 0x34, 0x3B, 0x30, 0x33, 0x3E, 0x36, 0x39, 0x3A, 0x3D, 0x31, 0x37,
     0x68, 0x6C, 0x65, 0x62, 0x6F, 0x64, 0x6B, 0x60, 0x63, 0x6E, 0x66, 0x69, 0x6A, 0x6D, 0x61, 0x67,
     0x98, 0x9C, 0x95, 0x92, 0x9F, 0x94, 0x9B, 0x90, 0x93, 0x9E, 0x96, 0x99, 0x9A, 0x9D, 0x91, 0x97,
     0x58, 0x5C, 0x55, 0x52, 0x5F, 0x54, 0x5B, 0x50, 0x53, 0x5E, 0x56, 0x59, 0x5A, 0x5D, 0x51, 0x57,
     0x08, 0x0C, 0x05, 0x02, 0x0F, 0x04, 0x0B, 0x00, 0x03, 0x0E, 0x06, 0x09, 0x0A, 0x0D, 0x01, 0x07,
     0xB8, 0xBC, 0xB5, 0xB2, 0xBF, 0xB4, 0xBB, 0xB0, 0xB3, 0xBE, 0xB6, 0xB9, 0xBA, 0xBD, 0xB1, 0xB7,
     0xC8, 0xCC, 0xC5, 0xC2, 0xCF, 0xC4, 0xCB, 0xC0, 0xC3, 0xCE, 0xC6, 0xC9, 0xCA, 0xCD, 0xC1, 0xC7,
     0x78, 0x7C, 0x75, 0x72, 0x7F, 0x74, 0x7B, 0x70, 0x73, 0x7E, 0x76, 0x79, 0x7A, 0x7D, 0x71, 0x77,
     0xA8, 0xAC, 0xA5, 0xA2, 0xAF, 0xA4, 0xAB, 0xA0, 0xA3, 0xAE, 0xA6, 0xA9, 0xAA, 0xAD, 0xA1, 0xA7,
     0xF8, 0xFC, 0xF5, 0xF2, 0xFF, 0xF4, 0xFB, 0xF0, 0xF3, 0xFE, 0xF6, 0xF9, 0xFA, 0xFD, 0xF1, 0xF7,
     0x28, 0x2C, 0x25, 0x22, 0x2F, 0x24, 0x2B, 0x20, 0x23, 0x2E, 0x26, 0x29, 0x2A, 0x2D, 0x21, 0x27,
     0x18, 0x1C, 0x15, 0x12, 0x1F, 0x14, 0x1B, 0x10, 0x13, 0x1E, 0x16, 0x19, 0x1A, 0x1D, 0x11, 0x17,
     0x88, 0x8C, 0x85, 0x82, 0x8F, 0x84, 0x8B, 0x80, 0x83, 0x8E, 0x86, 0x89, 0x8A, 0x8D, 0x81, 0x87,
     0xE8, 0xEC, 0xE5, 0xE2, 0xEF, 0xE4, 0xEB, 0xE0, 0xE3, 0xEE, 0xE6, 0xE9, 0xEA, 0xED, 0xE1, 0xE7,
    }
   }
  }
 };

/* ----------------------------------------------------------------------------------------------- */
/*! \brief  Структура для хранения внутренних данных в маскированной реализации Магмы. */
 struct magma_encrypted_keys {
  /*! \brief  Две ключевые последовательности - прямая и инвертированная. */
  ak_uint32 inkey[2][8];
  /*! \brief  Две маски для двух ключевых последовательностей, соответственно,
      прямой и инвертированной. */
  ak_uint32 inmask[2][8];
};

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция реализует один такт шифрующего преобразования ГОСТ 34.12-2015 (Mагма).

    @param x Обрабатываемая половина блока (более детально смотри описание сети Фейстеля).
    @return Результат криптографического преобразования.                                           */
/* ----------------------------------------------------------------------------------------------- */
 static inline ak_uint32 ak_magma_gostf_boxes( ak_uint32 x, const ak_uint8 i, const ak_uint8 j )
{
  x = (( ak_uint32 ) magma_boxes[j][i][3][x>>24 & 255] ) << 24 |
      (( ak_uint32 ) magma_boxes[j][i][2][x>>16 & 255] ) << 16 |
      (( ak_uint32 ) magma_boxes[j][i][1][x>> 8 & 255] ) <<  8 |
      (( ak_uint32 ) magma_boxes[j][i][0][x & 255] );
  return ( x<<11 | x>>21 );
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция зашифрования одного блока информации алгоритмом ГОСТ 34.12-2015 (Магма).

    @param skey Контекст секретного ключа.
    @param in Блок входной информации (открытый текст).
    @param out Блок выходной информации (шифртекст).                                               */
/* ----------------------------------------------------------------------------------------------- */
 static void ak_magma_encrypt_with_random_walk( ak_skey skey, ak_pointer in, ak_pointer out )
{
  ak_uint8 m[34];
  ak_uint32 i, mv = 0;
  ak_uint32 (*kp)[8] = ((struct magma_encrypted_keys *)skey->data)->inkey;
  ak_uint32 (*mp)[8] = ((struct magma_encrypted_keys *)skey->data)->inmask;
  register ak_uint32 n3, n4, p = 0;

 /* вырабатываем случайную траекторию */
  skey->generator.random( &skey->generator, &mv, sizeof( ak_uint32 ));

 /* формируем вектор раундовых поворотов */
  m[0] = m[33] = 0;
  for( i = 0; i < 32; i++ ) m[i+1] = (ak_uint8)(( mv >> i) & 0x01 );

 /* начинаем движение */
#ifdef AK_LITTLE_ENDIAN
  n3 = ((ak_uint32 *) in)[0]^( m[1] * 0xffffffff );
  n4 = ((ak_uint32 *) in)[1];
#else
  n3 = bswap_32( ((ak_uint32 *) in)[0] )^( m[1] * 0xffffffff );
  n4 = bswap_32( ((ak_uint32 *) in)[1] );
#endif

  p = n3; p -= mp[m[ 1]][7]; p += kp[m[ 1]][7] + m[ 1]; n4 ^= ak_magma_gostf_boxes( p, m[ 2] ^ m[ 0], m[ 1] );
  p = n4; p -= mp[m[ 2]][6]; p += kp[m[ 2]][6] + m[ 2]; n3 ^= ak_magma_gostf_boxes( p, m[ 3] ^ m[ 1], m[ 2] );
  p = n3; p -= mp[m[ 3]][5]; p += kp[m[ 3]][5] + m[ 3]; n4 ^= ak_magma_gostf_boxes( p, m[ 4] ^ m[ 2], m[ 3] );
  p = n4; p -= mp[m[ 4]][4]; p += kp[m[ 4]][4] + m[ 4]; n3 ^= ak_magma_gostf_boxes( p, m[ 5] ^ m[ 3], m[ 4] );
  p = n3; p -= mp[m[ 5]][3]; p += kp[m[ 5]][3] + m[ 5]; n4 ^= ak_magma_gostf_boxes( p, m[ 6] ^ m[ 4], m[ 5] );
  p = n4; p -= mp[m[ 6]][2]; p += kp[m[ 6]][2] + m[ 6]; n3 ^= ak_magma_gostf_boxes( p, m[ 7] ^ m[ 5], m[ 6] );
  p = n3; p -= mp[m[ 7]][1]; p += kp[m[ 7]][1] + m[ 7]; n4 ^= ak_magma_gostf_boxes( p, m[ 8] ^ m[ 6], m[ 7] );
  p = n4; p -= mp[m[ 8]][0]; p += kp[m[ 8]][0] + m[ 8]; n3 ^= ak_magma_gostf_boxes( p, m[ 9] ^ m[ 7], m[ 8] );

  p = n3; p -= mp[m[ 9]][7]; p += kp[m[ 9]][7] + m[ 9]; n4 ^= ak_magma_gostf_boxes( p, m[10] ^ m[ 8], m[ 9] );
  p = n4; p -= mp[m[10]][6]; p += kp[m[10]][6] + m[10]; n3 ^= ak_magma_gostf_boxes( p, m[11] ^ m[ 9], m[10] );
  p = n3; p -= mp[m[11]][5]; p += kp[m[11]][5] + m[11]; n4 ^= ak_magma_gostf_boxes( p, m[12] ^ m[10], m[11] );
  p = n4; p -= mp[m[12]][4]; p += kp[m[12]][4] + m[12]; n3 ^= ak_magma_gostf_boxes( p, m[13] ^ m[11], m[12] );
  p = n3; p -= mp[m[13]][3]; p += kp[m[13]][3] + m[13]; n4 ^= ak_magma_gostf_boxes( p, m[14] ^ m[12], m[13] );
  p = n4; p -= mp[m[14]][2]; p += kp[m[14]][2] + m[14]; n3 ^= ak_magma_gostf_boxes( p, m[15] ^ m[13], m[14] );
  p = n3; p -= mp[m[15]][1]; p += kp[m[15]][1] + m[15]; n4 ^= ak_magma_gostf_boxes( p, m[16] ^ m[14], m[15] );
  p = n4; p -= mp[m[16]][0]; p += kp[m[16]][0] + m[16]; n3 ^= ak_magma_gostf_boxes( p, m[17] ^ m[15], m[16] );

  p = n3; p -= mp[m[17]][7]; p += kp[m[17]][7] + m[17]; n4 ^= ak_magma_gostf_boxes( p, m[18] ^ m[16], m[17] );
  p = n4; p -= mp[m[18]][6]; p += kp[m[18]][6] + m[18]; n3 ^= ak_magma_gostf_boxes( p, m[19] ^ m[17], m[18] );
  p = n3; p -= mp[m[19]][5]; p += kp[m[19]][5] + m[19]; n4 ^= ak_magma_gostf_boxes( p, m[20] ^ m[18], m[19] );
  p = n4; p -= mp[m[20]][4]; p += kp[m[20]][4] + m[20]; n3 ^= ak_magma_gostf_boxes( p, m[21] ^ m[19], m[20] );
  p = n3; p -= mp[m[21]][3]; p += kp[m[21]][3] + m[21]; n4 ^= ak_magma_gostf_boxes( p, m[22] ^ m[20], m[21] );
  p = n4; p -= mp[m[22]][2]; p += kp[m[22]][2] + m[22]; n3 ^= ak_magma_gostf_boxes( p, m[23] ^ m[21], m[22] );
  p = n3; p -= mp[m[23]][1]; p += kp[m[23]][1] + m[23]; n4 ^= ak_magma_gostf_boxes( p, m[24] ^ m[22], m[23] );
  p = n4; p -= mp[m[24]][0]; p += kp[m[24]][0] + m[24]; n3 ^= ak_magma_gostf_boxes( p, m[25] ^ m[23], m[24] );

  p = n3; p -= mp[m[25]][0]; p += kp[m[25]][0] + m[25]; n4 ^= ak_magma_gostf_boxes( p, m[26] ^ m[24], m[25] );
  p = n4; p -= mp[m[26]][1]; p += kp[m[26]][1] + m[26]; n3 ^= ak_magma_gostf_boxes( p, m[27] ^ m[25], m[26] );
  p = n3; p -= mp[m[27]][2]; p += kp[m[27]][2] + m[27]; n4 ^= ak_magma_gostf_boxes( p, m[28] ^ m[26], m[27] );
  p = n4; p -= mp[m[28]][3]; p += kp[m[28]][3] + m[28]; n3 ^= ak_magma_gostf_boxes( p, m[29] ^ m[27], m[28] );
  p = n3; p -= mp[m[29]][4]; p += kp[m[29]][4] + m[29]; n4 ^= ak_magma_gostf_boxes( p, m[30] ^ m[28], m[29] );
  p = n4; p -= mp[m[30]][5]; p += kp[m[30]][5] + m[30]; n3 ^= ak_magma_gostf_boxes( p, m[31] ^ m[29], m[30] );
  p = n3; p -= mp[m[31]][6]; p += kp[m[31]][6] + m[31]; n4 ^= ak_magma_gostf_boxes( p, m[32] ^ m[30], m[31] );
  p = n4; p -= mp[m[32]][7]; p += kp[m[32]][7] + m[32]; n3 ^= ak_magma_gostf_boxes( p, m[33] ^ m[31], m[32] );

 #ifdef AK_LITTLE_ENDIAN
  ((ak_uint32 *)out)[0] = n4^( m[32] * 0xffffffff ); ((ak_uint32 *)out)[1] = n3;
 #else
  ((ak_uint32 *)out)[0] = bswap_32( n4 )^( m[32] * 0xffffffff ); ((ak_uint32 *)out)[1] = bswap_32( n3 );
 #endif
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция расшифрования одного блока информации маскированного
    алгоритмом ГОСТ 34.12-2015 (Магма).

    @param skey Контекст секретного ключа.
    @param in Блок входной информации (шифртекст).
    @param out Блок выходной информации (открытый текст).                                          */
/* ----------------------------------------------------------------------------------------------- */
 static void ak_magma_decrypt_with_random_walk( ak_skey skey, ak_pointer in, ak_pointer out )
{
  ak_uint8 m[34];
  ak_uint32 i, mv = 0;
  ak_uint32 (*kp)[8] = ((struct magma_encrypted_keys *)skey->data)->inkey;
  ak_uint32 (*mp)[8] = ((struct magma_encrypted_keys *)skey->data)->inmask;
  register ak_uint32 n3, n4, p = 0;

 /* вырабатываем случайную траекторию */
  skey->generator.random( &skey->generator, &mv, sizeof( ak_uint32 ));

 /* формируем вектор раундовых поворотов */
  m[0] = m[33] = 0;
  for( i = 0; i < 32; i++ ) m[i+1] = (ak_uint8)((mv >> i) & 0x01 );

 /* начинаем движение */
#ifdef AK_LITTLE_ENDIAN
  n3 = ((ak_uint32 *) in)[0]^( m[1] * 0xffffffff );
  n4 = ((ak_uint32 *) in)[1];
#else
  n3 = bswap_32( ((ak_uint32 *) in)[0] )^( m[1] * 0xffffffff );
  n4 = bswap_32( ((ak_uint32 *) in)[1] );
#endif

  p = (n3 - mp[m[ 1]][7]); p += kp[m[ 1]][7] + m[ 1]; n4 ^= ak_magma_gostf_boxes(p, m[ 2] ^ m[ 0], m[ 1] );
  p = (n4 - mp[m[ 2]][6]); p += kp[m[ 2]][6] + m[ 2]; n3 ^= ak_magma_gostf_boxes(p, m[ 3] ^ m[ 1], m[ 2] );
  p = (n3 - mp[m[ 3]][5]); p += kp[m[ 3]][5] + m[ 3]; n4 ^= ak_magma_gostf_boxes(p, m[ 4] ^ m[ 2], m[ 3] );
  p = (n4 - mp[m[ 4]][4]); p += kp[m[ 4]][4] + m[ 4]; n3 ^= ak_magma_gostf_boxes(p, m[ 5] ^ m[ 3], m[ 4] );
  p = (n3 - mp[m[ 5]][3]); p += kp[m[ 5]][3] + m[ 5]; n4 ^= ak_magma_gostf_boxes(p, m[ 6] ^ m[ 4], m[ 5] );
  p = (n4 - mp[m[ 6]][2]); p += kp[m[ 6]][2] + m[ 6]; n3 ^= ak_magma_gostf_boxes(p, m[ 7] ^ m[ 5], m[ 6] );
  p = (n3 - mp[m[ 7]][1]); p += kp[m[ 7]][1] + m[ 7]; n4 ^= ak_magma_gostf_boxes(p, m[ 8] ^ m[ 6], m[ 7] );
  p = (n4 - mp[m[ 8]][0]); p += kp[m[ 8]][0] + m[ 8]; n3 ^= ak_magma_gostf_boxes(p, m[ 9] ^ m[ 7], m[ 8] );

  p = (n3 - mp[m[ 9]][0]); p += kp[m[ 9]][0] + m[ 9]; n4 ^= ak_magma_gostf_boxes(p, m[10] ^ m[ 8], m[ 9] );
  p = (n4 - mp[m[10]][1]); p += kp[m[10]][1] + m[10]; n3 ^= ak_magma_gostf_boxes(p, m[11] ^ m[ 9], m[10] );
  p = (n3 - mp[m[11]][2]); p += kp[m[11]][2] + m[11]; n4 ^= ak_magma_gostf_boxes(p, m[12] ^ m[10], m[11] );
  p = (n4 - mp[m[12]][3]); p += kp[m[12]][3] + m[12]; n3 ^= ak_magma_gostf_boxes(p, m[13] ^ m[11], m[12] );
  p = (n3 - mp[m[13]][4]); p += kp[m[13]][4] + m[13]; n4 ^= ak_magma_gostf_boxes(p, m[14] ^ m[12], m[13] );
  p = (n4 - mp[m[14]][5]); p += kp[m[14]][5] + m[14]; n3 ^= ak_magma_gostf_boxes(p, m[15] ^ m[13], m[14] );
  p = (n3 - mp[m[15]][6]); p += kp[m[15]][6] + m[15]; n4 ^= ak_magma_gostf_boxes(p, m[16] ^ m[14], m[15] );
  p = (n4 - mp[m[16]][7]); p += kp[m[16]][7] + m[16]; n3 ^= ak_magma_gostf_boxes(p, m[17] ^ m[15], m[16] );

  p = (n3 - mp[m[17]][0]); p += kp[m[17]][0] + m[17]; n4 ^= ak_magma_gostf_boxes(p, m[18] ^ m[16], m[17] );
  p = (n4 - mp[m[18]][1]); p += kp[m[18]][1] + m[18]; n3 ^= ak_magma_gostf_boxes(p, m[19] ^ m[17], m[18] );
  p = (n3 - mp[m[19]][2]); p += kp[m[19]][2] + m[19]; n4 ^= ak_magma_gostf_boxes(p, m[20] ^ m[18], m[19] );
  p = (n4 - mp[m[20]][3]); p += kp[m[20]][3] + m[20]; n3 ^= ak_magma_gostf_boxes(p, m[21] ^ m[19], m[20] );
  p = (n3 - mp[m[21]][4]); p += kp[m[21]][4] + m[21]; n4 ^= ak_magma_gostf_boxes(p, m[22] ^ m[20], m[21] );
  p = (n4 - mp[m[22]][5]); p += kp[m[22]][5] + m[22]; n3 ^= ak_magma_gostf_boxes(p, m[23] ^ m[21], m[22] );
  p = (n3 - mp[m[23]][6]); p += kp[m[23]][6] + m[23]; n4 ^= ak_magma_gostf_boxes(p, m[24] ^ m[22], m[23] );
  p = (n4 - mp[m[24]][7]); p += kp[m[24]][7] + m[24]; n3 ^= ak_magma_gostf_boxes(p, m[25] ^ m[23], m[24] );

  p = (n3 - mp[m[25]][0]); p += kp[m[25]][0] + m[25]; n4 ^= ak_magma_gostf_boxes(p, m[26] ^ m[24], m[25] );
  p = (n4 - mp[m[26]][1]); p += kp[m[26]][1] + m[26]; n3 ^= ak_magma_gostf_boxes(p, m[27] ^ m[25], m[26] );
  p = (n3 - mp[m[27]][2]); p += kp[m[27]][2] + m[27]; n4 ^= ak_magma_gostf_boxes(p, m[28] ^ m[26], m[27] );
  p = (n4 - mp[m[28]][3]); p += kp[m[28]][3] + m[28]; n3 ^= ak_magma_gostf_boxes(p, m[29] ^ m[27], m[28] );
  p = (n3 - mp[m[29]][4]); p += kp[m[29]][4] + m[29]; n4 ^= ak_magma_gostf_boxes(p, m[30] ^ m[28], m[29] );
  p = (n4 - mp[m[30]][5]); p += kp[m[30]][5] + m[30]; n3 ^= ak_magma_gostf_boxes(p, m[31] ^ m[29], m[30] );
  p = (n3 - mp[m[31]][6]); p += kp[m[31]][6] + m[31]; n4 ^= ak_magma_gostf_boxes(p, m[32] ^ m[30], m[31] );
  p = (n4 - mp[m[32]][7]); p += kp[m[32]][7] + m[32]; n3 ^= ak_magma_gostf_boxes(p, m[33] ^ m[31], m[32] );

#ifdef AK_LITTLE_ENDIAN
  ((ak_uint32 *)out)[0] = n4 ^ (m[32] * 0xffffffff); ((ak_uint32 *)out)[1] = n3;
#else
  ((ak_uint32 *)out)[0] = bswap_32( n4 ) ^ (m[32] * 0xffffffff); ((ak_uint32 *)out)[1] = bswap_32( n3 );
#endif
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция зашифрования одного блока информации алгоритмом ГОСТ 34.12-2015 (Магма).
    Функция реализует режим совместимости с псевдопреобразованием, реализуемым библиотекой openssl.

    @param skey Контекст секретного ключа.
    @param in Блок входной информации (открытый текст).
    @param out Блок выходной информации (шифртекст).                                               */
/* ----------------------------------------------------------------------------------------------- */
 static void ak_magma_encrypt_with_random_walk_oc( ak_skey skey, ak_pointer in, ak_pointer out )
{
  ak_uint8 m[34];
  ak_uint32 i, mv = 0;
  ak_uint32 (*kp)[8] = ((struct magma_encrypted_keys *)skey->data)->inkey;
  ak_uint32 (*mp)[8] = ((struct magma_encrypted_keys *)skey->data)->inmask;
  register ak_uint32 n3, n4, p = 0;

 /* вырабатываем случайную траекторию */
  skey->generator.random( &skey->generator, &mv, sizeof( ak_uint32 ));

 /* формируем вектор раундовых поворотов */
  m[0] = m[1] = m[32] = m[33] = 0;
  for( i = 1; i < 31; i++ ) m[i+1] = (ak_uint8)(( mv >> i) & 0x01 );

 /* начинаем движение */
#ifdef AK_LITTLE_ENDIAN
  n4 = bswap_32( ((ak_uint32 *) in)[0] )^( m[1] * 0xffffffff );
  n3 = bswap_32( ((ak_uint32 *) in)[1] );
#else
  n4 = ((ak_uint32 *) in)[0]^( m[1] * 0xffffffff );
  n3 = ((ak_uint32 *) in)[1];
#endif

  p = n3; p -= mp[m[ 1]][7]; p += kp[m[ 1]][7] + m[ 1]; n4 ^= ak_magma_gostf_boxes( p, m[ 2] ^ m[ 0], m[ 1] );
  p = n4; p -= mp[m[ 2]][6]; p += kp[m[ 2]][6] + m[ 2]; n3 ^= ak_magma_gostf_boxes( p, m[ 3] ^ m[ 1], m[ 2] );
  p = n3; p -= mp[m[ 3]][5]; p += kp[m[ 3]][5] + m[ 3]; n4 ^= ak_magma_gostf_boxes( p, m[ 4] ^ m[ 2], m[ 3] );
  p = n4; p -= mp[m[ 4]][4]; p += kp[m[ 4]][4] + m[ 4]; n3 ^= ak_magma_gostf_boxes( p, m[ 5] ^ m[ 3], m[ 4] );
  p = n3; p -= mp[m[ 5]][3]; p += kp[m[ 5]][3] + m[ 5]; n4 ^= ak_magma_gostf_boxes( p, m[ 6] ^ m[ 4], m[ 5] );
  p = n4; p -= mp[m[ 6]][2]; p += kp[m[ 6]][2] + m[ 6]; n3 ^= ak_magma_gostf_boxes( p, m[ 7] ^ m[ 5], m[ 6] );
  p = n3; p -= mp[m[ 7]][1]; p += kp[m[ 7]][1] + m[ 7]; n4 ^= ak_magma_gostf_boxes( p, m[ 8] ^ m[ 6], m[ 7] );
  p = n4; p -= mp[m[ 8]][0]; p += kp[m[ 8]][0] + m[ 8]; n3 ^= ak_magma_gostf_boxes( p, m[ 9] ^ m[ 7], m[ 8] );

  p = n3; p -= mp[m[ 9]][7]; p += kp[m[ 9]][7] + m[ 9]; n4 ^= ak_magma_gostf_boxes( p, m[10] ^ m[ 8], m[ 9] );
  p = n4; p -= mp[m[10]][6]; p += kp[m[10]][6] + m[10]; n3 ^= ak_magma_gostf_boxes( p, m[11] ^ m[ 9], m[10] );
  p = n3; p -= mp[m[11]][5]; p += kp[m[11]][5] + m[11]; n4 ^= ak_magma_gostf_boxes( p, m[12] ^ m[10], m[11] );
  p = n4; p -= mp[m[12]][4]; p += kp[m[12]][4] + m[12]; n3 ^= ak_magma_gostf_boxes( p, m[13] ^ m[11], m[12] );
  p = n3; p -= mp[m[13]][3]; p += kp[m[13]][3] + m[13]; n4 ^= ak_magma_gostf_boxes( p, m[14] ^ m[12], m[13] );
  p = n4; p -= mp[m[14]][2]; p += kp[m[14]][2] + m[14]; n3 ^= ak_magma_gostf_boxes( p, m[15] ^ m[13], m[14] );
  p = n3; p -= mp[m[15]][1]; p += kp[m[15]][1] + m[15]; n4 ^= ak_magma_gostf_boxes( p, m[16] ^ m[14], m[15] );
  p = n4; p -= mp[m[16]][0]; p += kp[m[16]][0] + m[16]; n3 ^= ak_magma_gostf_boxes( p, m[17] ^ m[15], m[16] );

  p = n3; p -= mp[m[17]][7]; p += kp[m[17]][7] + m[17]; n4 ^= ak_magma_gostf_boxes( p, m[18] ^ m[16], m[17] );
  p = n4; p -= mp[m[18]][6]; p += kp[m[18]][6] + m[18]; n3 ^= ak_magma_gostf_boxes( p, m[19] ^ m[17], m[18] );
  p = n3; p -= mp[m[19]][5]; p += kp[m[19]][5] + m[19]; n4 ^= ak_magma_gostf_boxes( p, m[20] ^ m[18], m[19] );
  p = n4; p -= mp[m[20]][4]; p += kp[m[20]][4] + m[20]; n3 ^= ak_magma_gostf_boxes( p, m[21] ^ m[19], m[20] );
  p = n3; p -= mp[m[21]][3]; p += kp[m[21]][3] + m[21]; n4 ^= ak_magma_gostf_boxes( p, m[22] ^ m[20], m[21] );
  p = n4; p -= mp[m[22]][2]; p += kp[m[22]][2] + m[22]; n3 ^= ak_magma_gostf_boxes( p, m[23] ^ m[21], m[22] );
  p = n3; p -= mp[m[23]][1]; p += kp[m[23]][1] + m[23]; n4 ^= ak_magma_gostf_boxes( p, m[24] ^ m[22], m[23] );
  p = n4; p -= mp[m[24]][0]; p += kp[m[24]][0] + m[24]; n3 ^= ak_magma_gostf_boxes( p, m[25] ^ m[23], m[24] );

  p = n3; p -= mp[m[25]][0]; p += kp[m[25]][0] + m[25]; n4 ^= ak_magma_gostf_boxes( p, m[26] ^ m[24], m[25] );
  p = n4; p -= mp[m[26]][1]; p += kp[m[26]][1] + m[26]; n3 ^= ak_magma_gostf_boxes( p, m[27] ^ m[25], m[26] );
  p = n3; p -= mp[m[27]][2]; p += kp[m[27]][2] + m[27]; n4 ^= ak_magma_gostf_boxes( p, m[28] ^ m[26], m[27] );
  p = n4; p -= mp[m[28]][3]; p += kp[m[28]][3] + m[28]; n3 ^= ak_magma_gostf_boxes( p, m[29] ^ m[27], m[28] );
  p = n3; p -= mp[m[29]][4]; p += kp[m[29]][4] + m[29]; n4 ^= ak_magma_gostf_boxes( p, m[30] ^ m[28], m[29] );
  p = n4; p -= mp[m[30]][5]; p += kp[m[30]][5] + m[30]; n3 ^= ak_magma_gostf_boxes( p, m[31] ^ m[29], m[30] );
  p = n3; p -= mp[m[31]][6]; p += kp[m[31]][6] + m[31]; n4 ^= ak_magma_gostf_boxes( p, m[32] ^ m[30], m[31] );
  p = n4; p -= mp[m[32]][7]; p += kp[m[32]][7] + m[32]; n3 ^= ak_magma_gostf_boxes( p, m[33] ^ m[31], m[32] );

 #ifdef AK_LITTLE_ENDIAN
  ((ak_uint32 *)out)[1] = bswap_32( n4 )^( m[32] * 0xffffffff ); ((ak_uint32 *)out)[0] = bswap_32( n3 );
 #else
  ((ak_uint32 *)out)[1] = n4^( m[32] * 0xffffffff ); ((ak_uint32 *)out)[0] = n3;
 #endif
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция расшифрования одного блока информации маскированного
    алгоритмом ГОСТ 34.12-2015 (Магма).
    Функция реализует режим совместимости с псевдопреобразованием, реализуемым библиотекой openssl.

    @param skey Контекст секретного ключа.
    @param in Блок входной информации (шифртекст).
    @param out Блок выходной информации (открытый текст).                                          */
/* ----------------------------------------------------------------------------------------------- */
 static void ak_magma_decrypt_with_random_walk_oc( ak_skey skey, ak_pointer in, ak_pointer out )
{
  ak_uint8 m[34];
  ak_uint32 i, mv = 0;
  ak_uint32 (*kp)[8] = ((struct magma_encrypted_keys *)skey->data)->inkey;
  ak_uint32 (*mp)[8] = ((struct magma_encrypted_keys *)skey->data)->inmask;
  register ak_uint32 n3, n4, p = 0;

 /* вырабатываем случайную траекторию */
  skey->generator.random( &skey->generator, &mv, sizeof( ak_uint32 ));

 /* формируем вектор раундовых поворотов */
  m[0] = m[1] = m[32] = m[33] = 0;
  for( i = 1; i < 31; i++ ) m[i+1] = (ak_uint8)((mv >> i) & 0x01 );

 /* начинаем движение */
#ifdef AK_LITTLE_ENDIAN
  n4 = bswap_32( ((ak_uint32 *) in)[0] )^( m[1] * 0xffffffff );
  n3 = bswap_32( ((ak_uint32 *) in)[1] );
#else
  n4 = ((ak_uint32 *) in)[0]^( m[1] * 0xffffffff );
  n3 = ((ak_uint32 *) in)[1];
#endif

  p = (n3 - mp[m[ 1]][7]); p += kp[m[ 1]][7] + m[ 1]; n4 ^= ak_magma_gostf_boxes(p, m[ 2] ^ m[ 0], m[ 1] );
  p = (n4 - mp[m[ 2]][6]); p += kp[m[ 2]][6] + m[ 2]; n3 ^= ak_magma_gostf_boxes(p, m[ 3] ^ m[ 1], m[ 2] );
  p = (n3 - mp[m[ 3]][5]); p += kp[m[ 3]][5] + m[ 3]; n4 ^= ak_magma_gostf_boxes(p, m[ 4] ^ m[ 2], m[ 3] );
  p = (n4 - mp[m[ 4]][4]); p += kp[m[ 4]][4] + m[ 4]; n3 ^= ak_magma_gostf_boxes(p, m[ 5] ^ m[ 3], m[ 4] );
  p = (n3 - mp[m[ 5]][3]); p += kp[m[ 5]][3] + m[ 5]; n4 ^= ak_magma_gostf_boxes(p, m[ 6] ^ m[ 4], m[ 5] );
  p = (n4 - mp[m[ 6]][2]); p += kp[m[ 6]][2] + m[ 6]; n3 ^= ak_magma_gostf_boxes(p, m[ 7] ^ m[ 5], m[ 6] );
  p = (n3 - mp[m[ 7]][1]); p += kp[m[ 7]][1] + m[ 7]; n4 ^= ak_magma_gostf_boxes(p, m[ 8] ^ m[ 6], m[ 7] );
  p = (n4 - mp[m[ 8]][0]); p += kp[m[ 8]][0] + m[ 8]; n3 ^= ak_magma_gostf_boxes(p, m[ 9] ^ m[ 7], m[ 8] );

  p = (n3 - mp[m[ 9]][0]); p += kp[m[ 9]][0] + m[ 9]; n4 ^= ak_magma_gostf_boxes(p, m[10] ^ m[ 8], m[ 9] );
  p = (n4 - mp[m[10]][1]); p += kp[m[10]][1] + m[10]; n3 ^= ak_magma_gostf_boxes(p, m[11] ^ m[ 9], m[10] );
  p = (n3 - mp[m[11]][2]); p += kp[m[11]][2] + m[11]; n4 ^= ak_magma_gostf_boxes(p, m[12] ^ m[10], m[11] );
  p = (n4 - mp[m[12]][3]); p += kp[m[12]][3] + m[12]; n3 ^= ak_magma_gostf_boxes(p, m[13] ^ m[11], m[12] );
  p = (n3 - mp[m[13]][4]); p += kp[m[13]][4] + m[13]; n4 ^= ak_magma_gostf_boxes(p, m[14] ^ m[12], m[13] );
  p = (n4 - mp[m[14]][5]); p += kp[m[14]][5] + m[14]; n3 ^= ak_magma_gostf_boxes(p, m[15] ^ m[13], m[14] );
  p = (n3 - mp[m[15]][6]); p += kp[m[15]][6] + m[15]; n4 ^= ak_magma_gostf_boxes(p, m[16] ^ m[14], m[15] );
  p = (n4 - mp[m[16]][7]); p += kp[m[16]][7] + m[16]; n3 ^= ak_magma_gostf_boxes(p, m[17] ^ m[15], m[16] );

  p = (n3 - mp[m[17]][0]); p += kp[m[17]][0] + m[17]; n4 ^= ak_magma_gostf_boxes(p, m[18] ^ m[16], m[17] );
  p = (n4 - mp[m[18]][1]); p += kp[m[18]][1] + m[18]; n3 ^= ak_magma_gostf_boxes(p, m[19] ^ m[17], m[18] );
  p = (n3 - mp[m[19]][2]); p += kp[m[19]][2] + m[19]; n4 ^= ak_magma_gostf_boxes(p, m[20] ^ m[18], m[19] );
  p = (n4 - mp[m[20]][3]); p += kp[m[20]][3] + m[20]; n3 ^= ak_magma_gostf_boxes(p, m[21] ^ m[19], m[20] );
  p = (n3 - mp[m[21]][4]); p += kp[m[21]][4] + m[21]; n4 ^= ak_magma_gostf_boxes(p, m[22] ^ m[20], m[21] );
  p = (n4 - mp[m[22]][5]); p += kp[m[22]][5] + m[22]; n3 ^= ak_magma_gostf_boxes(p, m[23] ^ m[21], m[22] );
  p = (n3 - mp[m[23]][6]); p += kp[m[23]][6] + m[23]; n4 ^= ak_magma_gostf_boxes(p, m[24] ^ m[22], m[23] );
  p = (n4 - mp[m[24]][7]); p += kp[m[24]][7] + m[24]; n3 ^= ak_magma_gostf_boxes(p, m[25] ^ m[23], m[24] );

  p = (n3 - mp[m[25]][0]); p += kp[m[25]][0] + m[25]; n4 ^= ak_magma_gostf_boxes(p, m[26] ^ m[24], m[25] );
  p = (n4 - mp[m[26]][1]); p += kp[m[26]][1] + m[26]; n3 ^= ak_magma_gostf_boxes(p, m[27] ^ m[25], m[26] );
  p = (n3 - mp[m[27]][2]); p += kp[m[27]][2] + m[27]; n4 ^= ak_magma_gostf_boxes(p, m[28] ^ m[26], m[27] );
  p = (n4 - mp[m[28]][3]); p += kp[m[28]][3] + m[28]; n3 ^= ak_magma_gostf_boxes(p, m[29] ^ m[27], m[28] );
  p = (n3 - mp[m[29]][4]); p += kp[m[29]][4] + m[29]; n4 ^= ak_magma_gostf_boxes(p, m[30] ^ m[28], m[29] );
  p = (n4 - mp[m[30]][5]); p += kp[m[30]][5] + m[30]; n3 ^= ak_magma_gostf_boxes(p, m[31] ^ m[29], m[30] );
  p = (n3 - mp[m[31]][6]); p += kp[m[31]][6] + m[31]; n4 ^= ak_magma_gostf_boxes(p, m[32] ^ m[30], m[31] );
  p = (n4 - mp[m[32]][7]); p += kp[m[32]][7] + m[32]; n3 ^= ak_magma_gostf_boxes(p, m[33] ^ m[31], m[32] );

#ifdef AK_LITTLE_ENDIAN
  ((ak_uint32 *)out)[1] = bswap_32( n4 ) ^ (m[32] * 0xffffffff); ((ak_uint32 *)out)[0] = bswap_32( n3 );
#else
  ((ak_uint32 *)out)[1] = n4 ^ (m[32] * 0xffffffff); ((ak_uint32 *)out)[0] = n3;
#endif
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция уничтожения развернутых ключей для маскированной магмы

    В данной функции освобождается память выделенная под дополнительные s-боксы а хранящиеся маски
    и ключи заполняются случайнам мусором

    @param skey Указатель на контекст секретного ключа

    @return В случае успеха функция возвращает ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_magma_delete_keys (ak_skey skey)
{
  if( skey == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                            "using a null pointer to secret key" );
 /* если ключ был создан, но ему не было присвоено значение, здесь возникнет ошибка */
  if( skey->data != NULL ) {
    ak_ptr_wipe( skey->data, sizeof( struct magma_encrypted_keys ), &skey->generator );
    ak_aligned_free( skey->data );
    skey->data = NULL;
  }
 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция выработки инвертированного ключа и ключевых масок.

    @param skey Указатель на контекст секретного ключа

    @return В случае успеха функция возвращает \ref ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_magma_schedule_keys(ak_skey skey)
{
  int idx, error = ak_error_ok;
  struct magma_encrypted_keys *data = NULL;

  if( skey == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                        "using a null pointer to secret key" );
 /* проверяем целостность ключа */
  if( skey->check_icode( skey ) != ak_true ) return ak_error_message( ak_error_wrong_key_icode,
                                                __func__ , "using key with wrong integrity code" );
 /* удаляем былое */
  if( skey->data != NULL ) ak_magma_delete_keys( skey );

  if(( data = ak_aligned_malloc( sizeof( struct magma_encrypted_keys ))) == NULL )
    return ak_error_message( ak_error_out_of_memory, __func__, "incorrect memory allocation" );

 /* выставляем флаги того, что память выделена */
  memset( data, 0, sizeof( struct magma_encrypted_keys ));
  skey->data = ( ak_pointer )data;
  skey->flags |= key_flag_data_not_free;

 /* размещаем данные */
  if(( error = ak_random_ptr( &skey->generator, data->inmask, sizeof( data->inmask ))) != ak_error_ok )
    return ak_error_message( error, __func__, "incorrect generation first secret key mask" );

  for( idx = 0; idx < 8; idx++ ) {
     data->inkey[0][idx] = ((ak_uint32 *) skey->key )[idx];               /* скопировали */
     data->inkey[0][idx] += data->inmask[0][idx];                /* наложили новую маску */
     data->inkey[0][idx] -= ((ak_uint32 *) skey->key )[idx + 8];   /* сняли старую маску */
                                /* копирование с одновременным обращением (вычисляем ~k) */
     data->inkey[1][idx] = -data->inkey[0][idx];                 /* скопировали значение */
     data->inkey[1][idx] -= ( 1 - data->inmask[1][idx] );        /* наложили новую маску */
     data->inkey[1][idx] += data->inmask[0][idx];                  /* сняли старую маску */
  }

 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Наложение аддитивной в кольце \f$ \mathbb Z_{2^{32}}\f$ маски на ключ.

    Функция рассматривает вектор ключа как последовательность \f$ k_1, \ldots, k_n\f$, состоящую
    из элементов кольца  \f$ \mathbb Z_{2^{32}}\f$. Функция вырабатывает случайный вектор
    \f$ x_1, \ldots, x_n\f$ и заменяет ключевой вектор на последовательность значений
    \f$ k_1 + x_1 \pmod{2^{32}}, \ldots, k_n + x_n \pmod{2^{32}}\f$.

    @param skey Указатель на контекст секретного ключа. Длина ключа (в байтах)
    должна быть в точности равна 32.

    @return В случае успеха функция возвращает ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_skey_set_mask_additive( ak_skey skey )
{
  ak_uint32 newmask[8];
  size_t idx = 0, jdx = 0;
  int error = ak_error_ok;
  struct magma_encrypted_keys *data = NULL;

 /* "стандартные" проверки указателей и выделения памяти */
  if( skey == NULL ) return ak_error_message( ak_error_null_pointer,
                                         __func__ , "using a null pointer to secret key context" );
  if( skey->key == NULL ) return ak_error_message( ak_error_null_pointer,
                                                 __func__ , "using a null pointer to key buffer" );
  if( skey->key_size == 0 ) return ak_error_message( ak_error_zero_length, __func__ ,
                                                           "using a key buffer with zero length" );
 /* проверяем, установлена ли маска ранее */
  if((( skey->flags)&key_flag_set_mask ) == 0 ) {

   #ifdef AK_BIG_ENDIAN
    /* переворачиваем байты ключа для соответствия little endian */
     for( idx = 0; idx < 8; idx++ )
        ((ak_uint32 *)skey->key)[idx] = bswap_32( ((ak_uint32 *)skey->key)[idx] );
   #endif

    /* создаем маску*/
     if(( error = ak_random_ptr( &skey->generator, skey->key+32, 32 )) != ak_error_ok )
       return ak_error_message( error, __func__ , "wrong random mask generation for key buffer" );

    /* накладываем маску на ключ */
     for( idx = 0; idx < 8; idx++ )
        ((ak_uint32 *) skey->key)[idx] += ((ak_uint32 *) skey->key)[idx+8];

    /* меняем значение флага */
     skey->flags |= key_flag_set_mask;

  } else { /* если маска уже установлена, то мы сменяем ее на новую */

           /* для очень длинных ключей маска не изменяется */ /* выше проверка, что длина маски равна 32!! */
            if(( error = ak_random_ptr( &skey->generator, newmask, 32 )) != ak_error_ok )
              return ak_error_message( error, __func__ ,
                                                  "wrong random mask generation for key buffer" );
           /* меняем маску для вектора, хранящегося в структуре skey */
            for( idx = 0; idx < 8; idx++ ) {
               ((ak_uint32 *) skey->key)[idx] += newmask[idx];
               ((ak_uint32 *) skey->key)[idx] -= ((ak_uint32 *) skey->key)[idx+8];
               ((ak_uint32 *) skey->key)[idx+8] = newmask[idx];
            }
          /* меняем маску для внутреннего представления ключевой информации */
            if(( data = ( struct magma_encrypted_keys *)skey->data ) == NULL ) return error;
            for( jdx = 0; jdx < 2; jdx++ ) {
              if(( error = ak_random_ptr( &skey->generator, newmask, 32 )) != ak_error_ok )
                return ak_error_message( error, __func__ ,
                                                  "wrong random mask generation for key buffer" );
              for( idx = 0; idx < 8; idx++ ) {
                 data->inkey[jdx][idx] += newmask[idx];
                 data->inkey[jdx][idx] -= data->inmask[jdx][idx];
                 data->inmask[jdx][idx] = newmask[idx];
              }
            }
  }
 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Снятие аддитивной в кольце \f$ \mathbb Z_{2^{32}}\f$ маски на ключ.

    Функция снимает наложенную ранее маску и оставляет значение ключа в его истинном виде.
    В буффер `mask` помещается нулевое значение.
    @param skey Указатель на контекст секретного ключа.
    @return В случае успеха функция возвращает \ref ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_skey_unmask_additive( ak_skey skey )
{
  size_t idx = 0;

 /* "стандартные" проверки указателей и выделения памяти */
  if( skey == NULL ) return ak_error_message( ak_error_null_pointer,
                                         __func__ , "using a null pointer to secret key context" );
  if( skey->key == NULL ) return ak_error_message( ak_error_null_pointer,
                                                 __func__ , "using a null pointer to key buffer" );
  if( skey->key_size == 0 ) return ak_error_message( ak_error_zero_length, __func__ ,
                                                           "using a key buffer with zero length" );
 /* проверяем, установлена ли маска ранее */
  if( (( skey->flags)&key_flag_set_mask ) == 0 ) return ak_error_ok;

 /* снимаем маску с ключа */
  for( idx = 0; idx < 8; idx++ ) {
     ((ak_uint32 *) skey->key)[idx] -= ((ak_uint32 *) skey->key)[idx + 8];
     ((ak_uint32 *) skey->key)[8+idx] = 0;
  }

 #ifdef AK_BIG_ENDIAN
   /* делаем обратное переворачивание байт ключа */
   for( idx = 0; idx < 8; idx++ )
      ((ak_uint32 *)skey->key)[idx] = bswap_32( ((ak_uint32 *)skey->key)[idx] );
 #endif

 /* меняем значение флага */
  skey->flags ^= key_flag_set_mask;
 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Вычисление значения контрольной суммы ключа.

    @param skey Указатель на контекст секретного ключа. Длина ключа (в байтах)
    должна быть в точности равна 32.

    @return В случае успеха функция возвращает ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_skey_set_icode_additive( ak_skey skey )
{
  union {
    ak_uint32 x;
    unsigned short int v[2];
  } x, y;

 /* "стандартные" проверки указателей и выделения памяти */
  if( skey == NULL ) return ak_error_message( ak_error_null_pointer,
                                         __func__ , "using a null pointer to secret key context" );
  if( skey->key == NULL ) return ak_error_message( ak_error_null_pointer,
                                                 __func__ , "using a null pointer to key buffer" );
  if( skey->key_size == 0 ) return ak_error_message( ak_error_zero_length, __func__ ,
                                                           "using a key buffer with zero length" );
 /* в силу аддитивности контрольной суммы,
    мы вычисляем результат последовательно для ключа, а потом для его маски */

  ak_ptr_fletcher32( skey->key, 32, &x.x );
  ak_ptr_fletcher32( skey->key+32, 32, &y.x );
  x.v[0] -= y.v[0]; x.v[1] -= y.v[1];
  skey->icode = x.x;

 /* устанавливаем флаг */
  skey->flags |= key_flag_set_icode;

 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Проверка значения контрольной суммы ключа.

    @param skey Указатель на контекст секретного ключа. Длина ключа (в байтах)
    должна быть в точности равна 32.

    @return В случае совпадения контрольной суммы ключа функция возвращает истину (\ref ak_true).
    В противном случае, возвращается ложь (\ref ak_false).                                         */
/* ----------------------------------------------------------------------------------------------- */
 static bool_t ak_skey_check_icode_additive( ak_skey skey )
{
  union {
    ak_uint32 x;
    unsigned short int v[2];
  } x, y;

 /* "стандартные" проверки указателей и выделения памяти */
  if( skey == NULL ) { ak_error_message( ak_error_null_pointer,
                                         __func__ , "using a null pointer to secret key context" );
    return ak_false;
  }
  if( skey->key == NULL ) { ak_error_message( ak_error_null_pointer,
                                                 __func__ , "using a null pointer to key buffer" );
    return ak_false;
  }
  if( skey->key_size == 0 ) { ak_error_message( ak_error_zero_length, __func__ ,
                                                           "using a key buffer with zero length" );
    return ak_false;
  }

 /* в силу аддитивности контрольной суммы,
    мы вычисляем результат последоватлеьно для ключа, а потом для его маски */
  ak_ptr_fletcher32( skey->key, 32, &x.x );
  ak_ptr_fletcher32( skey->key+32, 32, &y.x );
  x.v[0] -= y.v[0]; x.v[1] -= y.v[1];

  if( y.x == 0 )return ak_true;
  if( skey->icode == x.x ) return ak_true;
    else return ak_false;
}

/* ----------------------------------------------------------------------------------------------- */
/*! Функция инициализируете контекст ключа алгоритма блочного шифрования Магма (ГОСТ Р 34.12-2015).
    После инициализации устанавливаются обработчики (функции класса). Однако само значение
    ключу не присваивается - поле `bkey->key` остается неопределенным.

    @param bkey Контекст секретного ключа алгоритма блочного шифрования.

    @return Функция возвращает код ошибки. В случаее успеха возвращается \ref ak_error_ok.         */
/* ----------------------------------------------------------------------------------------------- */
 int ak_bckey_create_magma( ak_bckey bkey )
{
  int error = ak_error_ok, oc = (int) ak_libakrypt_get_option_by_name( "openssl_compability" );

  if( bkey == NULL ) return ak_error_message( ak_error_null_pointer, __func__,
                                               "using null pointer to block cipher key context" );
  if(( oc < 0 ) || ( oc > 1 )) return ak_error_message( ak_error_wrong_option, __func__,
                                                "wrong value for \"openssl_compability\" option" );

 /* создаем ключ алгоритма шифрования и определяем его методы */
  if(( error = ak_bckey_create( bkey, 32, 8 )) != ak_error_ok )
    return ak_error_message( error, __func__, "wrong initalization of block cipher key context" );

 /* устанавливаем OID алгоритма шифрования */
  if(( bkey->key.oid = ak_oid_find_by_name( "magma" )) == NULL ) {
    error = ak_error_get_value();
    ak_error_message( error, __func__, "wrong search of predefined magma block cipher OID" );
    ak_bckey_destroy( bkey );
    return error;
  }

 /* ресурс ключа устанавливается в момент присвоения ключа */

 /* устанавливаем методы */
  bkey->key.set_mask = ak_skey_set_mask_additive;
  bkey->key.unmask = ak_skey_unmask_additive;
  bkey->key.set_icode = ak_skey_set_icode_additive;
  bkey->key.check_icode = ak_skey_check_icode_additive;

  bkey->schedule_keys = ak_magma_schedule_keys;
  bkey->delete_keys = ak_magma_delete_keys;
  if( oc ) {
    bkey->encrypt = ak_magma_encrypt_with_random_walk_oc;
    bkey->decrypt = ak_magma_decrypt_with_random_walk_oc;
  }
   else {
    bkey->encrypt = ak_magma_encrypt_with_random_walk;
    bkey->decrypt = ak_magma_decrypt_with_random_walk;
  }
  return error;
}

/* ----------------------------------------------------------------------------------------------- */
 static bool_t ak_libakrypt_test_magma_complete( void )
{
 /* значение секретного ключа согласно ГОСТ Р 34.12-2015 для алгоритма Магма, приложение А.2 */
  ak_uint8 key_magma[32] = {
     0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0,
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
  };

 /* тот же ключ, но в инвертированном виде */
  ak_uint8 openssl_key_magma[32] = {
     0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
     0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
  };

 /* открытый текст из ГОСТ Р 34.13-2015, приложение А.2 */
  ak_uint8 magma_in[32] = {
     0x59, 0x0a, 0x13, 0x3c, 0x6b, 0xf0, 0xde, 0x92,
     0x20, 0x9d, 0x18, 0xf8, 0x04, 0xc7, 0x54, 0xdb,
     0x4c, 0x02, 0xa8, 0x67, 0x2e, 0xfb, 0x98, 0x4a,
     0x41, 0x7e, 0xb5, 0x17, 0x9b, 0x40, 0x12, 0x89
 };

 /* тот же открытый текст из ГОСТ Р 34.13-2015, приложение А.2, но зеркально развернутый, поблочно */
  ak_uint8 openssl_magma_in[32] = {
     0x92, 0xde, 0xf0, 0x6b, 0x3c, 0x13, 0x0a, 0x59,
     0xdb, 0x54, 0xc7, 0x04, 0xf8, 0x18, 0x9d, 0x20,
     0x4a, 0x98, 0xfb, 0x2e, 0x67, 0xa8, 0x02, 0x4c,
     0x89, 0x12, 0x40, 0x9b, 0x17, 0xb5, 0x7e, 0x41
  };

  /* шифрованный текст для режима простой замены, ГОСТ Р 34.13-2015, приложение А.2 */
  ak_uint8 magma_out_ecb[32] = {
     0xa0, 0x72, 0xf3, 0x94, 0x04, 0x3f, 0x07, 0x2b,
     0x48, 0x6e, 0x55, 0xd3, 0x15, 0xe7, 0x70, 0xde,
     0x1e, 0xbc, 0xcf, 0xea, 0xe9, 0xd9, 0xd8, 0x11,
     0xfb, 0x7e, 0xc6, 0x96, 0x09, 0x26, 0x68, 0x7c
  };

  ak_uint8 openssl_magma_out_ecb[32] = {
     0x2b, 0x07, 0x3f, 0x04, 0x94, 0xf3, 0x72, 0xa0,
     0xde, 0x70, 0xe7, 0x15, 0xd3, 0x55, 0x6e, 0x48,
     0x11, 0xd8, 0xd9, 0xe9, 0xea, 0xcf, 0xbc, 0x1e,
     0x7c, 0x68, 0x26, 0x09, 0x96, 0xc6, 0x7e, 0xfb
  };

 /* инициализационный вектор для режима гаммирования (счетчика) */
  ak_uint8 magma_ivctr[4] = { 0x78, 0x56, 0x34, 0x12 };
  ak_uint8 openssl_magma_ivctr[4] = { 0x12, 0x34, 0x56, 0x78 };

 /* зашифрованный блок для режима гаммирования */
  ak_uint8 magma_out_ctr[32] = {
    0x3c, 0xb9, 0xb7, 0x97, 0x0c, 0x11, 0x98, 0x4e,
    0x69, 0x5d, 0xe8, 0xd6, 0x93, 0x0d, 0x25, 0x3e,
    0xef, 0xdb, 0xb2, 0x07, 0x88, 0x86, 0x6d, 0x13,
    0x2d, 0xa1, 0x52, 0xab, 0x80, 0xb6, 0x8e, 0x56,
  };
 /* тот же зашифрованный блок для режима гаммирования, но развернутый по блоково в стиле openssl */
  ak_uint8 openssl_magma_out_ctr[32] = {
    0x4e, 0x98, 0x11, 0x0c, 0x97, 0xb7, 0xb9, 0x3c,
    0x3e, 0x25, 0x0d, 0x93, 0xd6, 0xe8, 0x5d, 0x69,
    0x13, 0x6d, 0x86, 0x88, 0x07, 0xb2, 0xdb, 0xef,
    0x56, 0x8e, 0xb6, 0x80, 0xab, 0x52, 0xa1, 0x2d,
  };

 /* инициализационный вектор для режима гаммирования (счетчика) */
  ak_uint8 magma_ivcbc[24] = {
    0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12,
    0xf1, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23,
    0x12, 0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34
  };

  ak_uint8 openssl_magma_ivcbc[24] = {
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x23, 0x45, 0x67, 0x89, 0x0a, 0xbc, 0xde, 0xf1,
    0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12
  };

 /* инициализационный вектор для режима гаммирования с обратной связью по выходу
      и он же
    инициализационный вектор для режима гаммирования с обратной связью по шифртексту */
  ak_uint8 magma_ivofb[16] = {
    0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12,
    0xf1, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23,
  };

  ak_uint8 openssl_magma_ivofb[16] = {
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x23, 0x45, 0x67, 0x89, 0x0a, 0xbc, 0xde, 0xf1,
  };

 /* зашифрованный блок из ГОСТ Р 34.12-2015 для режима простой замены */
  ak_uint8 magma_out_cbc[32] = {
    0x19, 0x39, 0x68, 0xea, 0x5e, 0xb0, 0xd1, 0x96,
    0xb9, 0x37, 0xb9, 0xab, 0x29, 0x61, 0xf7, 0xaf,
    0x19, 0x00, 0xbc, 0xc4, 0xa1, 0xb4, 0x58, 0x50,
    0x67, 0xe6, 0xd7, 0x7c, 0x1a, 0x8b, 0xb7, 0x20
  };
  ak_uint8 openssl_magma_out_cbc[32] = {
    0x96, 0xd1, 0xb0, 0x5e, 0xea, 0x68, 0x39, 0x19,
    0xaf, 0xf7, 0x61, 0x29, 0xab, 0xb9, 0x37, 0xb9,
    0x50, 0x58, 0xb4, 0xa1, 0xc4, 0xbc, 0x00, 0x19,
    0x20, 0xb7, 0x8b, 0x1a, 0x7c, 0xd7, 0xe6, 0x67
  };

 /* зашифрованный блок из ГОСТ Р 34.12-2015 для режима гаммирования с обратной связью по выходу */
  ak_uint8 magma_outofb[32] = {
    0x83, 0x3c, 0x90, 0x66, 0xe2, 0xe0, 0x37, 0xdb,
    0x9c, 0x08, 0x9a, 0x1f, 0x4c, 0x64, 0x46, 0x0d,
    0x7e, 0x32, 0x0e, 0x43, 0x62, 0x30, 0xf8, 0xa0,
    0x05, 0xdb, 0x4f, 0xbd, 0xb8, 0xef, 0x24, 0xc8
  };

  ak_uint8 openssl_magma_outofb[32] = {
    0xdb, 0x37, 0xe0, 0xe2, 0x66, 0x90, 0x3c, 0x83,
    0x0d, 0x46, 0x64, 0x4c, 0x1f, 0x9a, 0x08, 0x9c,
    0xa0, 0xf8, 0x30, 0x62, 0x43, 0x0e, 0x32, 0x7e,
    0xc8, 0x24, 0xef, 0xb8, 0xbd, 0x4f, 0xdb, 0x05
  };

 /* зашифрованный блок из ГОСТ Р 34.12-2015 для режима гаммирования с обратной связью по шифртексту */
  ak_uint8 magma_outcfb[32] = {
    0x83, 0x3c, 0x90, 0x66, 0xe2, 0xe0, 0x37, 0xdb,
    0x9c, 0x08, 0x9a, 0x1f, 0x4c, 0x64, 0x46, 0x0d,
    0x8b, 0xd3, 0x15, 0x53, 0x03, 0xd2, 0xbd, 0x24,
    0x05, 0x55, 0x07, 0x21, 0x14, 0x32, 0xc0, 0xbc
  };
  ak_uint8 openssl_magma_outcfb[32] = {
    0xdb, 0x37, 0xe0, 0xe2, 0x66, 0x90, 0x3c, 0x83,
    0x0d, 0x46, 0x64, 0x4c, 0x1f, 0x9a, 0x08, 0x9c,
    0x24, 0xbd, 0xd2, 0x03, 0x53, 0x15, 0xd3, 0x8b,
    0xbc, 0xc0, 0x32, 0x14, 0x21, 0x07, 0x55, 0x05
  };

 /* значение имитовставки согласно ГОСТ Р 34.13-2015 (раздел А.2.6) */
  ak_uint8 imito[4] = {
    /* 0xbb, 0xc5, 0x20, 0x30 - первая часть выработанного блока */
    0x10, 0x72, 0x4e, 0x15
  };
  ak_uint8 openssl_imito[4] = {
    0x15, 0x4e, 0x72, 0x10 /* 0x20, 0x30, 0xc5, 0xbb - остальные вырабатываемые байты */
  };

  ak_uint32 idx;
  struct hmac hkey;
  struct bckey mkey;
  ak_uint8 icode[8];
  size_t i = 0, j = 0;
  ak_uint8 myout[256];
  bool_t result = ak_true;
  int error = ak_error_ok, audit = ak_log_get_level(),
      oc = (int) ak_libakrypt_get_option_by_name( "openssl_compability" );

 /* Проверка используемого режима совместимости */
  if(( oc < 0 ) || ( oc > 1 )) {
    ak_error_message( ak_error_wrong_option, __func__,
                                                "wrong value for \"openssl_compability\" option" );
    return ak_false;
  }
  if( audit >= ak_log_maximum ) {
   if( oc == ak_false ) ak_error_message( ak_error_ok, __func__ , "testing in base mode" );
     else ak_error_message( ak_error_ok, __func__ , "testing with openssl compability" );
  }

 /* Проверка тестируемых данных */
  for( i = 0; i < sizeof( key_magma ); i++ )
    if( key_magma[i] != openssl_key_magma[31-i] ) result = ak_false;
  if( result != ak_true ) {
    ak_error_message( ak_error_invalid_value, __func__,
                                                "incorrect constant values for magma secret key" );
    return ak_false;
  }
  for( j = 0; j < 4; j++ ) {
     for( i = 0; i < 8; i++ )
       if( magma_in[8*j+i] != openssl_magma_in[8*j+7-i] ) result = ak_false;
     if( result != ak_true ) {
       ak_error_message( ak_error_invalid_value, __func__,
                                                      "incorrect constant values for input data" );
       return ak_false;
     }
  }

 /* ------------------------------------------------------------------------ */
 /* 1. Создаем контекст ключа алгоритма Магма и устанавливаем значение ключа */
 /* ------------------------------------------------------------------------ */
  if(( error = ak_bckey_create_magma( &mkey )) != ak_error_ok ) {
    ak_error_message( error, __func__, "incorrect initialization of magma secret key context");
    return ak_false;
  }

  if(( error = ak_bckey_set_key( &mkey, oc ? openssl_key_magma : key_magma,
                                                           sizeof( key_magma ))) != ak_error_ok ) {
    ak_error_message( error, __func__, "wrong creation of test key" );
    result = ak_false;
    goto exit;
  }

 /* ------------------------------------------------------------------------------------------- */
 /* 2. Проверяем независимую обработку блоков - режим простой замены согласно ГОСТ Р 34.12-2015 */
 /* ------------------------------------------------------------------------------------------- */
  if(( error = ak_bckey_encrypt_ecb( &mkey, oc ? openssl_magma_in : magma_in,
                                                     myout, sizeof( magma_in ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong ecb mode encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_out_ecb :
                                                         magma_out_ecb, sizeof( magma_out_ecb ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the ecb mode encryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }

  if(( error = ak_bckey_decrypt_ecb( &mkey, oc ? openssl_magma_out_ecb :
                                 magma_out_ecb, myout, sizeof( magma_out_ecb ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong ecb mode decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_in : magma_in, sizeof( magma_in ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the ecb mode decryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                "the ecb mode encryption/decryption test from GOST R 34.13-2015 is Ok" );

 /* ----------------------------------------------------------------- */
 /* 3. Проверяем режим гаммирования согласно ГОСТ Р 34.12-2015        */
 /* ----------------------------------------------------------------- */
  if(( error = ak_bckey_ctr( &mkey, oc ? openssl_magma_in : magma_in,
                   myout, sizeof( magma_in ), oc ? openssl_magma_ivctr : magma_ivctr,
                                                         sizeof( magma_ivctr ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong counter mode encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_out_ctr :
                                                         magma_out_ctr, sizeof( magma_out_ctr ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the counter mode encryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }

  if(( error = ak_bckey_ctr( &mkey, oc ? openssl_magma_out_ctr : magma_out_ctr,
                        myout, sizeof( magma_out_ecb ), oc ? openssl_magma_ivctr : magma_ivctr,
                                                         sizeof( magma_ivctr ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong counter mode decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_in : magma_in, sizeof( magma_in ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the counter mode decryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                "the counter mode encryption/decryption test from GOST R 34.13-2015 is Ok" );


 /* ----------------------------------------------------------------- */
 /* 4. Проверяем режим простой замены с зацеплением (cbc)             */
 /* ----------------------------------------------------------------- */
  if(( error = ak_bckey_encrypt_cbc( &mkey, oc ? openssl_magma_in : magma_in,
                 myout, sizeof( magma_in ), oc ? openssl_magma_ivcbc : magma_ivcbc,
                                                         sizeof( magma_ivcbc ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong cbc mode encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_out_cbc :
                                                         magma_out_cbc, sizeof( magma_out_cbc ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the cbc mode encryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if(( error = ak_bckey_decrypt_cbc( &mkey, oc ? openssl_magma_out_cbc : magma_out_cbc,
                 myout, sizeof( magma_in ), oc ? openssl_magma_ivcbc : magma_ivcbc,
                                                         sizeof( magma_ivcbc ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong cbc mode decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_in :
                                                              magma_in, sizeof( magma_out_cbc ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the cbc mode decryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                "the cbc mode encryption/decryption test from GOST R 34.13-2015 is Ok" );

 /* ----------------------------------------------------------------- */
 /* 5. Проверяем режим гаммирования с обратной связью по выходу (ofb) */
 /* ----------------------------------------------------------------- */
  if(( error = ak_bckey_ofb( &mkey, oc ? openssl_magma_in : magma_in,
                 myout, sizeof( magma_in ), oc ? openssl_magma_ivofb : magma_ivofb,
                                                         sizeof( magma_ivofb ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong ofb mode encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_outofb :
                                                           magma_outofb, sizeof( magma_outofb ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the ofb mode encryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if(( error = ak_bckey_ofb( &mkey, oc ? openssl_magma_outofb : magma_outofb,
                 myout, sizeof( magma_in ), oc ? openssl_magma_ivofb : magma_ivofb,
                                                         sizeof( magma_ivofb ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong ofb mode decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_in : magma_in, sizeof( magma_outofb ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the ofb mode decryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                "the ofb mode encryption/decryption test from GOST R 34.13-2015 is Ok" );


 /* ----------------------------------------------------------------- */
 /* 6. Проверяем режим гаммирования с обратной связью по выходу (cfb) */
 /* ----------------------------------------------------------------- */
  if(( error = ak_bckey_encrypt_cfb( &mkey, oc ? openssl_magma_in : magma_in,
                 myout, sizeof( magma_in ), oc ? openssl_magma_ivofb : magma_ivofb, /* синхропосылка одна и та же */
                                                         sizeof( magma_ivofb ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong cfb mode encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_outcfb :
                                                           magma_outcfb, sizeof( magma_outcfb ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the cfb mode encryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if(( error = ak_bckey_decrypt_cfb( &mkey, oc ? openssl_magma_outcfb : magma_outcfb,
                 myout, sizeof( magma_outcfb ), oc ? openssl_magma_ivofb : magma_ivofb,
                                                         sizeof( magma_ivofb ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong cfb mode decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_magma_in : magma_in, sizeof( magma_in ))) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                        "the cfb mode decryption test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                "the cfb mode encryption/decryption test from GOST R 34.13-2015 is Ok" );


 /* ----------------------------------------------------------------- */
 /* 10. Тестируем режим выработки имитовставки (плоская реализация).  */
 /* ----------------------------------------------------------------- */
  if(( error = ak_bckey_cmac( &mkey, oc ? openssl_magma_in : magma_in,
                                                 sizeof( magma_in ), myout, 4 )) != ak_error_ok ) {
    ak_error_message( error, __func__ , "wrong cmac calculation" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal_with_log( myout, oc ? openssl_imito : imito, 4 )) {
    ak_error_message( ak_error_not_equal_data, __func__ ,
                                        "the cmac integrity test from GOST R 34.13-2015 is wrong");
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                          "the cmac integrity test from GOST R 34.13-2015 is Ok" );

 /* 11. Несколько странный тест для одновременного шифрования и имитозащиты, алгоритм ctr-cmac */
  memset( myout, 0, sizeof( myout ));
  ak_random_ptr( &mkey.key.generator, myout, sizeof( myout ) - mkey.bsize );
  if(( error = ak_bckey_cmac( &mkey,
                   myout, sizeof( myout ) - mkey.bsize, icode, sizeof( icode ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "incorrect integrity code calculation");
    result = ak_false;
    goto exit;
  }

  /* Далее, мы тестируем данные, сдвигая их на 8 байт.
     При сдвиге на меньшее значение, например 1 байт,
     эмулятор qemu не может обработать не выровненные данные.
     Для исправления этой ошибки необходима реализация
     копирования данных в промежуточный, выровненный буффер,
     что для большинства компиляторов только замедляет работу */

  for( idx = 0; idx < sizeof( myout ) - mkey.bsize; idx += 8 ) {
   /* зашифровываем и вычисляем имитовставку */
     ak_bckey_encrypt_ctr_cmac( &mkey, &mkey,
        myout, idx,
        myout+idx, myout+idx, sizeof( myout ) - mkey.bsize - idx,
        magma_ivctr, sizeof( magma_ivctr ), myout + (sizeof( myout ) - mkey.bsize), 8 );
    /* сравниваем имитовставку с вычисленным ранее значением */
     if( !ak_ptr_is_equal_with_log( icode, myout + (sizeof( myout ) - mkey.bsize), 8 )) {
       ak_error_message_fmt( error, __func__ ,
                           "incorrect checking of precalculated integrity code on round %u", idx );
       result = ak_false;
       goto exit;
     }

    /* расшифровываем и снова проверяем имитовставку */
     if(( error = ak_bckey_decrypt_ctr_cmac( &mkey, &mkey,
        myout, idx,
        myout+idx, myout+idx, sizeof( myout ) - mkey.bsize - idx,
        magma_ivctr, sizeof( magma_ivctr ),
                                   myout + (sizeof( myout ) - mkey.bsize), 8 )) != ak_error_ok ) {
        ak_error_message_fmt( error, __func__ ,
                                                "incorrect decrypt for ctr-cmac on round %u", idx );
        result = ak_false;
        goto exit;
      }
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                              "the ctr-cmac integrity test for random data is Ok" );

 /* 12. Второй несколько странный тест для одновременного шифрования и имитозащиты, алгоритм ctr-hmac
    теперь нам потребуется ключ алгоритма hmac */
  if(( error = ak_hmac_create_streebog512( &hkey )) != ak_error_ok ) {
    ak_error_message( error, __func__, "incorrect creation of hmac secret key" );
    result = ak_false;
    goto exit;
  } else ak_hmac_set_key( &hkey, key_magma, sizeof( key_magma ));

  memset( myout, 0, sizeof( myout ));
  ak_random_ptr( &mkey.key.generator, myout, sizeof( myout ) - mkey.bsize );
  if(( error = ak_hmac_ptr( &hkey,
              myout, sizeof( myout ) - sizeof( icode ), icode, sizeof( icode ))) != ak_error_ok ) {
    ak_error_message( error, __func__ , "incorrect integrity code calculation");
    ak_hmac_destroy( &hkey );
    result = ak_false;
    goto exit;
  }

  for( idx = 0; idx < sizeof( myout ) - sizeof( icode ); idx += 8 ) {
   /* зашифровываем и вычисляем имитовставку */
     ak_bckey_encrypt_ctr_hmac( &mkey, &hkey,
        myout, idx,
        myout+idx, myout+idx, sizeof( myout ) - sizeof( icode ) - idx,
        magma_ivctr, sizeof( magma_ivctr ), myout + (sizeof( myout ) - sizeof( icode )), 8 );
    /* сравниваем имитовставку с вычисленным ранее значением */
     if( !ak_ptr_is_equal_with_log( icode, myout + (sizeof( myout ) - sizeof( icode )), 8 )) {
       ak_error_message_fmt( error, __func__ ,
                               "incorrect checking precalculated integrity code on round %u", idx );
       ak_hmac_destroy( &hkey );
       result = ak_false;
       goto exit;
     }
    /* расшифровываем и снова проверяем имитовставку */
     if(( error = ak_bckey_decrypt_ctr_hmac( &mkey, &hkey,
        myout, idx,
        myout+idx, myout+idx, sizeof( myout ) - sizeof( icode ) - idx,
        magma_ivctr, sizeof( magma_ivctr ),
                               myout + (sizeof( myout ) - sizeof( icode )), 8 )) != ak_error_ok ) {
        ak_error_message_fmt( error, __func__ ,
                                                "incorrect decrypt for ctr-cmac on round %u", idx );
        ak_hmac_destroy( &hkey );
        result = ak_false;
        goto exit;
      }
  }

  ak_hmac_destroy( &hkey );
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                              "the ctr-hmac integrity test for random data is Ok" );

 /* освобождаем ключ и выходим */
  exit:
  if(( error = ak_bckey_destroy( &mkey )) != ak_error_ok ) {
    ak_error_message( error, __func__, "wrong destroying of secret key" );
    return ak_false;
  }

 return result;
}

/* ----------------------------------------------------------------------------------------------- */
 bool_t ak_libakrypt_test_magma( void )
{
 int oc = (int) ak_libakrypt_get_option_by_name( "openssl_compability" );

 /* мы тестируем алгоритм Магма в двух режимах совместимисти,
    вызывая для этого функцию тестирования дважды

    сначала запуск в базовом режиме работы библиотеки */
   ak_libakrypt_set_openssl_compability( ak_false );
   if( ak_libakrypt_test_magma_complete() != ak_true ) {
     ak_error_message( ak_error_get_value(), __func__ ,
                                            "incorrect testing of magma algorithm in base mode" );
     return ak_false;
   }

 /* потом запускаем тестирование в режиме совместимости с openssl */
   ak_libakrypt_set_openssl_compability( ak_true );
   if( ak_libakrypt_test_magma_complete() != ak_true ) {
     ak_error_message( ak_error_get_value(), __func__ ,
                         "incorrect testing of magma algorithm in mode with openssl compability" );
     return ak_false;
   }

 /* восстанавливаем первоначальное состояние */
   ak_libakrypt_set_openssl_compability( oc );
   if( ak_log_get_level() >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                                        "testing of magma block cipher is Ok" );
 return ak_true;
}

/* ----------------------------------------------------------------------------------------------- */
/*                                                                                     ak_magma.c  */
/* ----------------------------------------------------------------------------------------------- */
